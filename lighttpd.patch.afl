diff --git a/src/connections.c b/src/connections.c
index 51afa665..ef82d25c 100644
--- a/src/connections.c
+++ b/src/connections.c
@@ -30,34 +30,35 @@
 /* keep in sync with h1.c */
 #define HTTP_LINGER_TIMEOUT 5
 
-#define connection_set_state(r,state)       request_set_state((r),(state))
-#define connection_set_state_error(r,state) request_set_state_error((r),(state))
+#define connection_set_state(r, state) request_set_state((r), (state))
+#define connection_set_state_error(r, state) request_set_state_error((r), (state))
 
+__attribute_cold__ static connection *connection_init(server *srv);
 
-__attribute_cold__
-static connection *connection_init(server *srv);
-
-__attribute_noinline__
-static void connection_reset(connection *con);
+__attribute_noinline__ static void connection_reset(connection *con);
 
-static connection *connections_get_new_connection(server *srv) {
+static connection *connections_get_new_connection(server *srv)
+{
     connection *con;
     --srv->lim_conns;
-    if (srv->conns_pool) {
+    if (srv->conns_pool)
+    {
         con = srv->conns_pool;
         srv->conns_pool = con->next;
     }
-    else {
+    else
+    {
         con = connection_init(srv);
         connection_reset(con);
     }
-    /*con->prev = NULL;*//*(already set)*/
+    /*con->prev = NULL;*/ /*(already set)*/
     if ((con->next = srv->conns))
         con->next->prev = con;
     return (srv->conns = con);
 }
 
-static void connection_del(server *srv, connection *con) {
+static void connection_del(server *srv, connection *con)
+{
     if (con->next)
         con->next->prev = con->prev;
     if (con->prev)
@@ -70,105 +71,119 @@ static void connection_del(server *srv, connection *con) {
     ++srv->lim_conns;
 }
 
-static void connection_close(connection *con) {
-	if (con->fd < 0) con->fd = -con->fd;
+static void connection_close(connection *con)
+{
+    if (con->fd < 0)
+        con->fd = -con->fd;
 
-	plugins_call_handle_connection_close(con);
+    plugins_call_handle_connection_close(con);
 
-	server * const srv = con->srv;
-	request_st * const r = &con->request;
-	request_reset_ex(r); /*(r->conf.* is still valid below)*/
-	connection_set_state(r, CON_STATE_CONNECT);
+    server *const srv = con->srv;
+    request_st *const r = &con->request;
+    request_reset_ex(r); /*(r->conf.* is still valid below)*/
+    connection_set_state(r, CON_STATE_CONNECT);
 
-	chunkqueue_reset(con->read_queue);
-	con->request_count = 0;
-	con->is_ssl_sock = 0;
-	con->revents_err = 0;
+    chunkqueue_reset(con->read_queue);
+    con->request_count = 0;
+    con->is_ssl_sock = 0;
+    con->revents_err = 0;
 
-	fdevent_fdnode_event_del(srv->ev, con->fdn);
-	fdevent_unregister(srv->ev, con->fdn);
-	con->fdn = NULL;
-	if (0 != fdio_close_socket(con->fd))
-		log_serror(r->conf.errh, __FILE__, __LINE__,
-		  "(warning) close: %d", con->fd);
+    fdevent_fdnode_event_del(srv->ev, con->fdn);
+    fdevent_unregister(srv->ev, con->fdn);
+    con->fdn = NULL;
+    if (0 != fdio_close_socket(con->fd))
+        log_serror(r->conf.errh, __FILE__, __LINE__,
+                   "(warning) close: %d", con->fd);
 
-	if (r->conf.log_state_handling) {
-		log_error(r->conf.errh, __FILE__, __LINE__,
-		  "connection closed for fd %d", con->fd);
-	}
-	con->fd = -1;
+    if (r->conf.log_state_handling)
+    {
+        log_error(r->conf.errh, __FILE__, __LINE__,
+                  "connection closed for fd %d", con->fd);
+    }
+    con->fd = -1;
 
-	--srv->cur_fds;
-	connection_del(srv, con);
+    --srv->cur_fds;
+    connection_del(srv, con);
 }
 
-static void connection_read_for_eos_plain(connection * const con) {
-	/* we have to do the linger_on_close stuff regardless
-	 * of r->keep_alive; even non-keepalive sockets
-	 * may still have unread data, and closing before reading
-	 * it will make the client not see all our output.
-	 */
-	ssize_t len;
-	const int type = sock_addr_get_family(&con->dst_addr);
-	char buf[16384];
-	do {
-		len = fdevent_socket_read_discard(con->fd, buf, sizeof(buf),
-						  type, SOCK_STREAM);
-	} while (len > 0 || (len < 0 && errno == EINTR));
-
-	if (len < 0 && errno == EAGAIN) return;
-      #if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
-	if (len < 0 && errno == EWOULDBLOCK) return;
-      #endif
+static void connection_read_for_eos_plain(connection *const con)
+{
+    /* we have to do the linger_on_close stuff regardless
+     * of r->keep_alive; even non-keepalive sockets
+     * may still have unread data, and closing before reading
+     * it will make the client not see all our output.
+     */
+    ssize_t len;
+    const int type = sock_addr_get_family(&con->dst_addr);
+    char buf[16384];
+    do
+    {
+        len = fdevent_socket_read_discard(con->fd, buf, sizeof(buf),
+                                          type, SOCK_STREAM);
+    } while (len > 0 || (len < 0 && errno == EINTR));
+
+    if (len < 0 && errno == EAGAIN)
+        return;
+#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
+    if (len < 0 && errno == EWOULDBLOCK)
+        return;
+#endif
 
-	/* 0 == len || (len < 0 && (errno is a non-recoverable error)) */
-		con->close_timeout_ts = log_monotonic_secs - (HTTP_LINGER_TIMEOUT+1);
+    /* 0 == len || (len < 0 && (errno is a non-recoverable error)) */
+    con->close_timeout_ts = log_monotonic_secs - (HTTP_LINGER_TIMEOUT + 1);
 }
 
-static void connection_read_for_eos_ssl(connection * const con) {
-	if (con->network_read(con, con->read_queue, MAX_READ_LIMIT) < 0)
-		con->close_timeout_ts = log_monotonic_secs - (HTTP_LINGER_TIMEOUT+1);
-	chunkqueue_reset(con->read_queue);
+static void connection_read_for_eos_ssl(connection *const con)
+{
+    if (con->network_read(con, con->read_queue, MAX_READ_LIMIT) < 0)
+        con->close_timeout_ts = log_monotonic_secs - (HTTP_LINGER_TIMEOUT + 1);
+    chunkqueue_reset(con->read_queue);
 }
 
-static void connection_read_for_eos(connection * const con) {
-	!con->is_ssl_sock
-	  ? connection_read_for_eos_plain(con)
-	  : connection_read_for_eos_ssl(con);
+static void connection_read_for_eos(connection *const con)
+{
+    !con->is_ssl_sock
+        ? connection_read_for_eos_plain(con)
+        : connection_read_for_eos_ssl(con);
 }
 
-static void connection_handle_close_state(connection *con) {
-	connection_read_for_eos(con);
+static void connection_handle_close_state(connection *con)
+{
+    connection_read_for_eos(con);
 
-	if (log_monotonic_secs - con->close_timeout_ts > HTTP_LINGER_TIMEOUT) {
-		connection_close(con);
-	}
+    if (log_monotonic_secs - con->close_timeout_ts > HTTP_LINGER_TIMEOUT)
+    {
+        connection_close(con);
+    }
 }
 
-static void connection_handle_shutdown(connection *con) {
-	plugins_call_handle_connection_shut_wr(con);
+static void connection_handle_shutdown(connection *con)
+{
+    plugins_call_handle_connection_shut_wr(con);
 
-	connection_reset(con);
+    connection_reset(con);
 
-	/* close the connection */
-	if (con->fd >= 0
-	    && (con->is_ssl_sock || 0 == shutdown(con->fd, SHUT_WR))) {
-		con->close_timeout_ts = log_monotonic_secs;
+    /* close the connection */
+    if (con->fd >= 0 && (con->is_ssl_sock || 0 == shutdown(con->fd, SHUT_WR)))
+    {
+        con->close_timeout_ts = log_monotonic_secs;
 
-		request_st * const r = &con->request;
-		connection_set_state(r, CON_STATE_CLOSE);
-		if (r->conf.log_state_handling) {
-			log_error(r->conf.errh, __FILE__, __LINE__,
-			  "shutdown for fd %d", con->fd);
-		}
-	} else {
-		connection_close(con);
-	}
+        request_st *const r = &con->request;
+        connection_set_state(r, CON_STATE_CLOSE);
+        if (r->conf.log_state_handling)
+        {
+            log_error(r->conf.errh, __FILE__, __LINE__,
+                      "shutdown for fd %d", con->fd);
+        }
+    }
+    else
+    {
+        connection_close(con);
+    }
 }
 
-
 static void
-connection_handle_request_start_state (request_st * const r, connection * const con)
+connection_handle_request_start_state(request_st *const r, connection *const con)
 {
     /*connection_set_state(r, CON_STATE_REQUEST_START);*/
     ++con->request_count;
@@ -179,70 +194,93 @@ connection_handle_request_start_state (request_st * const r, connection * const
         log_clock_gettime_realtime(&r->start_hp);
 }
 
+static void connection_handle_response_end_state(request_st *const r, connection *const con)
+{
+    if (r->http_version > HTTP_VERSION_1_1)
+    {
+        r->keep_alive = 0;
+        /* set a status so that mod_accesslog, mod_rrdtool hooks are called
+         * in plugins_call_handle_request_done() (XXX: or set to 0 to omit) */
+        r->http_status = 100; /* XXX: what if con->state == CON_STATE_ERROR? */
+                              /*if (r->http_status)*/
+        plugins_call_handle_request_done(r);
+
+        // LEO AVOIDING CLOSING CONNECTION, RESET INSTEAD
+        // connection_handle_shutdown(con);
+        request_reset(r);
+        con->is_readable = 1; /* potentially trigger optimistic read */
+        /*(accounting used by mod_accesslog for HTTP/1.0 and HTTP/1.1)*/
+        /*(overloaded to detect next bytes recv'd on keep-alive con)*/
+        r->x.h1.bytes_read_ckpt = r->read_queue.bytes_in;
+        r->x.h1.bytes_written_ckpt = r->write_queue.bytes_out;
+        connection_set_state(r, CON_STATE_REQUEST_START);
+        return;
+    }
+
+    /* call request_done hook if http_status set (e.g. to log request) */
+    /* (even if error, connection dropped, as long as http_status is set) */
+    if (r->http_status)
+    {
+        plugins_call_handle_request_done(r);
+    }
+
+    if (r->reqbody_length != r->reqbody_queue.bytes_in || r->state == CON_STATE_ERROR)
+    {
+        /* request body may not have been read completely */
+        r->keep_alive = 0;
+        /* clean up failed partial write of 1xx intermediate responses*/
+        if (&r->write_queue != con->write_queue)
+        { /*(for HTTP/1.1)*/
+            chunkqueue_free(con->write_queue);
+            con->write_queue = &r->write_queue;
+        }
+    }
 
-static void connection_handle_response_end_state(request_st * const r, connection * const con) {
-	if (r->http_version > HTTP_VERSION_1_1) {
-		r->keep_alive = 0;
-		/* set a status so that mod_accesslog, mod_rrdtool hooks are called
-		 * in plugins_call_handle_request_done() (XXX: or set to 0 to omit) */
-		r->http_status = 100; /* XXX: what if con->state == CON_STATE_ERROR? */
-		/*if (r->http_status)*/
-			plugins_call_handle_request_done(r);
-		connection_handle_shutdown(con);
-		return;
-	}
-
-	/* call request_done hook if http_status set (e.g. to log request) */
-	/* (even if error, connection dropped, as long as http_status is set) */
-	if (r->http_status) plugins_call_handle_request_done(r);
-
-	if (r->reqbody_length != r->reqbody_queue.bytes_in
-	    || r->state == CON_STATE_ERROR) {
-		/* request body may not have been read completely */
-		r->keep_alive = 0;
-		/* clean up failed partial write of 1xx intermediate responses*/
-		if (&r->write_queue != con->write_queue) { /*(for HTTP/1.1)*/
-			chunkqueue_free(con->write_queue);
-			con->write_queue = &r->write_queue;
-		}
-	}
-
-        if (r->keep_alive > 0) {
-		request_reset(r);
-		con->is_readable = 1; /* potentially trigger optimistic read */
-		/*(accounting used by mod_accesslog for HTTP/1.0 and HTTP/1.1)*/
-		/*(overloaded to detect next bytes recv'd on keep-alive con)*/
-		r->x.h1.bytes_read_ckpt = r->read_queue.bytes_in;
-		r->x.h1.bytes_written_ckpt = r->write_queue.bytes_out;
+    if (r->keep_alive > 0)
+    {
+        request_reset(r);
+        con->is_readable = 1; /* potentially trigger optimistic read */
+        /*(accounting used by mod_accesslog for HTTP/1.0 and HTTP/1.1)*/
+        /*(overloaded to detect next bytes recv'd on keep-alive con)*/
+        r->x.h1.bytes_read_ckpt = r->read_queue.bytes_in;
+        r->x.h1.bytes_written_ckpt = r->write_queue.bytes_out;
 #if 0
 		r->start_hp.tv_sec = log_epoch_secs;
 		con->read_idle_ts = log_monotonic_secs;
 #endif
-		connection_set_state(r, CON_STATE_REQUEST_START);
-	} else {
-		connection_handle_shutdown(con);
-	}
+        connection_set_state(r, CON_STATE_REQUEST_START);
+    }
+    else
+    {
+        // LEO AVOIDING CLOSING CONNECTION, RESET INSTEAD
+        // connection_handle_shutdown(con);
+        request_reset(r);
+        con->is_readable = 1; /* potentially trigger optimistic read */
+        /*(accounting used by mod_accesslog for HTTP/1.0 and HTTP/1.1)*/
+        /*(overloaded to detect next bytes recv'd on keep-alive con)*/
+        r->x.h1.bytes_read_ckpt = r->read_queue.bytes_in;
+        r->x.h1.bytes_written_ckpt = r->write_queue.bytes_out;
+        connection_set_state(r, CON_STATE_REQUEST_START);
+    }
 }
 
-
-__attribute_pure__
-static off_t
-connection_write_throttled (const connection * const con, off_t max_bytes)
+__attribute_pure__ static off_t
+connection_write_throttled(const connection *const con, off_t max_bytes)
 {
-    const request_config * const restrict rconf = &con->request.conf;
+    const request_config *const restrict rconf = &con->request.conf;
     if (0 == rconf->global_bytes_per_second && 0 == rconf->bytes_per_second)
         return max_bytes;
 
-    if (rconf->global_bytes_per_second) {
-        off_t limit = (off_t)rconf->global_bytes_per_second
-                    - *(rconf->global_bytes_per_second_cnt_ptr);
+    if (rconf->global_bytes_per_second)
+    {
+        off_t limit = (off_t)rconf->global_bytes_per_second - *(rconf->global_bytes_per_second_cnt_ptr);
         if (max_bytes > limit)
             max_bytes = limit;
     }
 
-    if (rconf->bytes_per_second) {
-        off_t limit = (off_t)rconf->bytes_per_second
-                    - con->bytes_written_cur_second;
+    if (rconf->bytes_per_second)
+    {
+        off_t limit = (off_t)rconf->bytes_per_second - con->bytes_written_cur_second;
         if (max_bytes > limit)
             max_bytes = limit;
     }
@@ -250,33 +288,33 @@ connection_write_throttled (const connection * const con, off_t max_bytes)
     return max_bytes > 0 ? max_bytes : 0; /*(0 == reached traffic limit)*/
 }
 
-
 static off_t
-connection_write_throttle (connection * const con, off_t max_bytes)
+connection_write_throttle(connection *const con, off_t max_bytes)
 {
     /*assert(max_bytes > 0);*/
     max_bytes = connection_write_throttled(con, max_bytes);
-    if (0 == max_bytes) con->traffic_limit_reached = 1;
+    if (0 == max_bytes)
+        con->traffic_limit_reached = 1;
     return max_bytes;
 }
 
-
 static int
-connection_write_chunkqueue (connection * const con, chunkqueue * const restrict cq, off_t max_bytes)
+connection_write_chunkqueue(connection *const con, chunkqueue *const restrict cq, off_t max_bytes)
 {
-    /*assert(!chunkqueue_is_empty(cq));*//* checked by callers */
+    /*assert(!chunkqueue_is_empty(cq));*/ /* checked by callers */
 
     con->write_request_ts = log_monotonic_secs;
 
     max_bytes = connection_write_throttle(con, max_bytes);
-    if (0 == max_bytes) return 1;
+    if (0 == max_bytes)
+        return 1;
 
     off_t written = cq->bytes_out;
     int ret;
 
-  #ifdef TCP_CORK
+#ifdef TCP_CORK
     int corked = 0;
-  #endif
+#endif
 
     /* walk chunkqueue up to first FILE_CHUNK (if present)
      * This may incur memory load misses for pointer chasing, but effectively
@@ -285,97 +323,114 @@ connection_write_chunkqueue (connection * const con, chunkqueue * const restrict
      * walked the entire chunkqueue (on each and every call).  The loads here
      * make a measurable difference in performance in underlying call to
      * con->network_write() */
-    if (cq->first->next && cq->first->type == MEM_CHUNK) {
+    if (cq->first->next && cq->first->type == MEM_CHUNK)
+    {
         const chunk *c = cq->first;
-        do { c = c->next; } while (c && c->type == MEM_CHUNK);
-      #ifdef TCP_CORK
+        do
+        {
+            c = c->next;
+        } while (c && c->type == MEM_CHUNK);
+#ifdef TCP_CORK
         /* Linux: put a cork into socket as we want to combine write() calls
          * but only if we really have multiple chunks including non-MEM_CHUNK
          * (or if multiple chunks and TLS), and only if TCP socket */
         /* (max_bytes may have been reduced by connection_write_throttle(),
          *  but not bothering to check; might result in some extra corking) */
-        if (NULL != c || (con->is_ssl_sock && chunkqueue_length(cq) > 16384)) {
+        if (NULL != c || (con->is_ssl_sock && chunkqueue_length(cq) > 16384))
+        {
             const int sa_family = sock_addr_get_family(&con->srv_socket->addr);
-            if (sa_family == AF_INET || sa_family == AF_INET6) {
+            if (sa_family == AF_INET || sa_family == AF_INET6)
+            {
                 corked = 1;
                 (void)setsockopt(con->fd, IPPROTO_TCP, TCP_CORK,
                                  &corked, sizeof(corked));
             }
         }
-      #endif
+#endif
     }
 
     ret = con->network_write(con, cq, max_bytes);
-    if (ret >= 0) {
+    if (ret >= 0)
+    {
         ret = chunkqueue_is_empty(cq) ? 0 : 1;
     }
 
-  #ifdef TCP_CORK
-    if (corked) {
+#ifdef TCP_CORK
+    if (corked)
+    {
         corked = 0;
         (void)setsockopt(con->fd, IPPROTO_TCP, TCP_CORK,
                          &corked, sizeof(corked));
     }
-  #endif
+#endif
 
     written = cq->bytes_out - written;
     con->bytes_written_cur_second += written;
-    request_st * const r = &con->request;
+    request_st *const r = &con->request;
     if (r->conf.global_bytes_per_second_cnt_ptr)
         *(r->conf.global_bytes_per_second_cnt_ptr) += written;
 
     return ret;
 }
 
+static int connection_handle_write(request_st *const r, connection *const con)
+{
+    /*assert(!chunkqueue_is_empty(cq));*/ /* checked by callers */
+
+    if (con->is_writable <= 0)
+        return CON_STATE_WRITE;
+    int rc = connection_write_chunkqueue(con, con->write_queue, MAX_WRITE_LIMIT);
+    switch (rc)
+    {
+    case 0:
+        if (r->resp_body_finished)
+        {
+            connection_set_state(r, CON_STATE_RESPONSE_END);
+            return CON_STATE_RESPONSE_END;
+        }
+        break;
+    case -1: /* error on our side */
+        log_error(r->conf.errh, __FILE__, __LINE__,
+                  "connection closed: write failed on fd %d", con->fd);
+    __attribute_fallthrough__ case -2: /* remote close */
+        connection_set_state_error(r, CON_STATE_ERROR);
+        return CON_STATE_ERROR;
+    case 1:
+        /* do not spin trying to send HTTP/2 server Connection Preface
+         * while waiting for TLS negotiation to complete */
+        if (con->write_queue->bytes_out)
+            con->is_writable = 0;
+
+        /* not finished yet -> WRITE */
+        break;
+    }
+
+    return CON_STATE_WRITE; /*(state did not change)*/
+}
 
-static int connection_handle_write(request_st * const r, connection * const con) {
-	/*assert(!chunkqueue_is_empty(cq));*//* checked by callers */
-
-	if (con->is_writable <= 0) return CON_STATE_WRITE;
-	int rc = connection_write_chunkqueue(con, con->write_queue, MAX_WRITE_LIMIT);
-	switch (rc) {
-	case 0:
-		if (r->resp_body_finished) {
-			connection_set_state(r, CON_STATE_RESPONSE_END);
-			return CON_STATE_RESPONSE_END;
-		}
-		break;
-	case -1: /* error on our side */
-		log_error(r->conf.errh, __FILE__, __LINE__,
-		  "connection closed: write failed on fd %d", con->fd);
-		__attribute_fallthrough__
-	case -2: /* remote close */
-		connection_set_state_error(r, CON_STATE_ERROR);
-		return CON_STATE_ERROR;
-	case 1:
-		/* do not spin trying to send HTTP/2 server Connection Preface
-		 * while waiting for TLS negotiation to complete */
-		if (con->write_queue->bytes_out)
-			con->is_writable = 0;
-
-		/* not finished yet -> WRITE */
-		break;
-	}
-
-	return CON_STATE_WRITE; /*(state did not change)*/
-}
-
-static int connection_handle_write_state(request_st * const r, connection * const con) {
-    do {
+static int connection_handle_write_state(request_st *const r, connection *const con)
+{
+    do
+    {
         /* only try to write if we have something in the queue */
-        if (!chunkqueue_is_empty(&r->write_queue)) {
+        if (!chunkqueue_is_empty(&r->write_queue))
+        {
             int rc = connection_handle_write(r, con);
-            if (rc != CON_STATE_WRITE) return rc;
+            if (rc != CON_STATE_WRITE)
+                return rc;
         }
-        else if (r->resp_body_finished) {
+        else if (r->resp_body_finished)
+        {
             connection_set_state(r, CON_STATE_RESPONSE_END);
             return CON_STATE_RESPONSE_END;
         }
 
-        if (r->handler_module && !r->resp_body_finished) {
-            const plugin * const p = r->handler_module;
+        if (r->handler_module && !r->resp_body_finished)
+        {
+            const plugin *const p = r->handler_module;
             int rc = p->handle_subrequest(r, p->data);
-            switch(rc) {
+            switch (rc)
+            {
             case HANDLER_WAIT_FOR_EVENT:
             case HANDLER_FINISHED:
             case HANDLER_GO_ON:
@@ -388,35 +443,34 @@ static int connection_handle_write_state(request_st * const r, connection * cons
             }
         }
     } while (!chunkqueue_is_empty(&r->write_queue)
-             ? con->is_writable > 0 && 0 == con->traffic_limit_reached
-             : r->resp_body_finished);
+                 ? con->is_writable > 0 && 0 == con->traffic_limit_reached
+                 : r->resp_body_finished);
 
     return CON_STATE_WRITE;
 }
 
+__attribute_cold__ static connection *connection_init(server *srv)
+{
+    connection *const con = ck_calloc(1, sizeof(*con));
 
-__attribute_cold__
-static connection *connection_init(server *srv) {
-	connection * const con = ck_calloc(1, sizeof(*con));
-
-	con->srv = srv;
-	con->plugin_slots = srv->plugin_slots;
-	con->config_data_base = srv->config_data_base;
+    con->srv = srv;
+    con->plugin_slots = srv->plugin_slots;
+    con->config_data_base = srv->config_data_base;
 
-	request_st * const r = &con->request;
-	request_init_data(r, con, srv);
-	con->write_queue = &r->write_queue;
-	con->read_queue = &r->read_queue;
+    request_st *const r = &con->request;
+    request_init_data(r, con, srv);
+    con->write_queue = &r->write_queue;
+    con->read_queue = &r->read_queue;
 
-	/* init plugin-specific per-connection structures */
-	con->plugin_ctx = ck_calloc(srv->plugins.used + 1, sizeof(void *));
+    /* init plugin-specific per-connection structures */
+    con->plugin_ctx = ck_calloc(srv->plugins.used + 1, sizeof(void *));
 
-	return con;
+    return con;
 }
 
-
-static void connection_free(connection * const con) {
-    request_st * const r = &con->request;
+static void connection_free(connection *const con)
+{
+    request_st *const r = &con->request;
 
     connection_reset(con);
     if (con->write_queue != &r->write_queue)
@@ -430,41 +484,43 @@ static void connection_free(connection * const con) {
     free(con);
 }
 
-void connections_pool_clear(server * const srv) {
+void connections_pool_clear(server *const srv)
+{
     connection *con;
-    while ((con = srv->conns_pool)) {
+    while ((con = srv->conns_pool))
+    {
         srv->conns_pool = con->next;
         connection_free(con);
     }
 }
 
-void connections_free(server *srv) {
+void connections_free(server *srv)
+{
     connections_pool_clear(srv);
 
     connection *con;
-    while ((con = srv->conns)) {
+    while ((con = srv->conns))
+    {
         srv->conns = con->next;
         connection_free(con);
     }
 }
 
-
-static void connection_reset(connection *con) {
-	request_st * const r = &con->request;
-	request_reset(r);
-	con->is_readable = 1;
-	con->bytes_written_cur_second = 0;
-	con->fn = NULL;
+static void connection_reset(connection *con)
+{
+    request_st *const r = &con->request;
+    request_reset(r);
+    con->is_readable = 1;
+    con->bytes_written_cur_second = 0;
+    con->fn = NULL;
 }
 
-
-__attribute_cold__
-static void
-connection_transition_h2 (request_st * const h2r, connection * const con)
+__attribute_cold__ static void
+connection_transition_h2(request_st *const h2r, connection *const con)
 {
-    buffer_copy_string_len(&h2r->target,      CONST_STR_LEN("*"));
+    buffer_copy_string_len(&h2r->target, CONST_STR_LEN("*"));
     buffer_copy_string_len(&h2r->target_orig, CONST_STR_LEN("*"));
-    buffer_copy_string_len(&h2r->uri.path,    CONST_STR_LEN("*"));
+    buffer_copy_string_len(&h2r->uri.path, CONST_STR_LEN("*"));
     h2r->http_method = HTTP_METHOD_PRI;
     h2r->reqbody_length = -1; /*(unnecessary for h2r?)*/
     h2r->conf.stream_request_body |= FDEVENT_STREAM_REQUEST_POLLIN;
@@ -479,9 +535,9 @@ connection_transition_h2 (request_st * const h2r, connection * const con)
 
     connection_set_state(h2r, CON_STATE_WRITE);
 
-  #if 0 /* ... if it turns out we need a separate fdevent handler for HTTP/2 */
+#if 0 /* ... if it turns out we need a separate fdevent handler for HTTP/2 */
     con->fdn->handler = connection_handle_fdevent_h2;
-  #endif
+#endif
 
     /* r->conf.h2proto must be checked prior to setting r->http_version to
      * HTTP_VERSION_2, so if we get here, http_dispatch[HTTP_VERSION_2] inited*/
@@ -489,9 +545,9 @@ connection_transition_h2 (request_st * const h2r, connection * const con)
         http_dispatch[HTTP_VERSION_2].upgrade_h2(h2r, con);
 }
 
-
-static handler_t connection_handle_fdevent(void * const context, const int revents) {
-    connection * restrict con = context;
+static handler_t connection_handle_fdevent(void *const context, const int revents)
+{
+    connection *restrict con = context;
     const int is_ssl_sock = con->is_ssl_sock;
 
     joblist_append(con);
@@ -499,10 +555,12 @@ static handler_t connection_handle_fdevent(void * const context, const int reven
     if (revents & ~(FDEVENT_IN | FDEVENT_OUT))
         con->revents_err |= (revents & ~(FDEVENT_IN | FDEVENT_OUT));
 
-    if (revents & (FDEVENT_IN | FDEVENT_OUT)) {
+    if (revents & (FDEVENT_IN | FDEVENT_OUT))
+    {
         if (is_ssl_sock) /*(ssl may read and write for both reads and writes)*/
             con->is_readable = con->is_writable = 1;
-        else {
+        else
+        {
             if (revents & FDEVENT_IN)
                 con->is_readable = 1;
             if (revents & FDEVENT_OUT)
@@ -513,28 +571,29 @@ static handler_t connection_handle_fdevent(void * const context, const int reven
     return HANDLER_FINISHED;
 }
 
-
-__attribute_cold__
-static int connection_read_cq_err(connection *con) {
-    request_st * const r = &con->request;
-  #ifdef _WIN32
-    switch (WSAGetLastError()) {
-      case WSAEWOULDBLOCK:
+__attribute_cold__ static int connection_read_cq_err(connection *con)
+{
+    request_st *const r = &con->request;
+#ifdef _WIN32
+    switch (WSAGetLastError())
+    {
+    case WSAEWOULDBLOCK:
         return 0;
-      case WSAEINTR:
+    case WSAEINTR:
         /* we have been interrupted before we could read */
         con->is_readable = 1;
         return 0;
-      case WSAECONNRESET:
+    case WSAECONNRESET:
         /* suppress logging for this error, expected for keep-alive */
         break;
     default:
         log_serror(r->conf.errh, __FILE__, __LINE__,
-          "connection closed - recv failed");
+                   "connection closed - recv failed");
         break;
     }
-  #else
-    switch (errno) {
+#else
+    switch (errno)
+    {
     case EAGAIN:
         return 0;
     case EINTR:
@@ -546,201 +605,201 @@ static int connection_read_cq_err(connection *con) {
         break;
     default:
         log_perror(r->conf.errh, __FILE__, __LINE__,
-          "connection closed - read failed");
+                   "connection closed - read failed");
         break;
     }
-  #endif
+#endif
 
     connection_set_state_error(r, CON_STATE_ERROR);
     return -1;
 }
 
-
 /* 0: everything ok, -1: error, -2: con closed */
-static int connection_read_cq(connection *con, chunkqueue *cq, off_t max_bytes) {
+static int connection_read_cq(connection *con, chunkqueue *cq, off_t max_bytes)
+{
     ssize_t len;
     size_t mem_len = 0;
 
-    do {
+    do
+    {
         /* obtain chunk memory into which to read
          * fill previous chunk if it has a reasonable amount of space available
          * (use mem_len=0 to obtain large buffer at least half of chunk_buf_sz)
          */
         chunk *ckpt = cq->last;
-        char * const mem = chunkqueue_get_memory(cq, &mem_len);
-        if (mem_len > (size_t)max_bytes) mem_len = (size_t)max_bytes;
+        char *const mem = chunkqueue_get_memory(cq, &mem_len);
+        if (mem_len > (size_t)max_bytes)
+            mem_len = (size_t)max_bytes;
 
-      #ifdef _WIN32
+#ifdef _WIN32
         len = recv(con->fd, mem, mem_len, 0);
-      #else
+#else
         len = read(con->fd, mem, mem_len);
-      #endif
+#endif
 
         chunkqueue_use_memory(cq, ckpt, len > 0 ? len : 0);
 
-        if (len != (ssize_t)mem_len) {
+        if (len != (ssize_t)mem_len)
+        {
             /* we got less than expected, wait for the next fd-event */
             con->is_readable = 0;
-            return len > 0 ? 0 : 0 == len ? -2 : connection_read_cq_err(con);
+            return len > 0 ? 0 : 0 == len ? -2
+                                          : connection_read_cq_err(con);
         }
 
         max_bytes -= len;
 
         int frd;
         mem_len = (0 == fdevent_ioctl_fionread(con->fd, S_IFSOCK, &frd))
-          ? (frd < max_bytes) ? (size_t)frd : (size_t)max_bytes
-          : 0;
+                      ? (frd < max_bytes) ? (size_t)frd : (size_t)max_bytes
+                      : 0;
     } while (max_bytes);
     return 0;
 }
 
-
-static int connection_write_cq(connection *con, chunkqueue *cq, off_t max_bytes) {
-    request_st * const r = &con->request;
-    return con->srv->network_backend_write(con->fd,cq,max_bytes,r->conf.errh);
+static int connection_write_cq(connection *con, chunkqueue *cq, off_t max_bytes)
+{
+    request_st *const r = &con->request;
+    return con->srv->network_backend_write(con->fd, cq, max_bytes, r->conf.errh);
 }
 
+connection *connection_accepted(server *srv, const server_socket *srv_socket, sock_addr *cnt_addr, int cnt)
+{
+    connection *con;
 
-connection *connection_accepted(server *srv, const server_socket *srv_socket, sock_addr *cnt_addr, int cnt) {
-		connection *con;
-
-		srv->cur_fds++;
+    srv->cur_fds++;
 
-		/* ok, we have the connection, register it */
+    /* ok, we have the connection, register it */
 #if 0
 		log_error(srv->errh, __FILE__, __LINE__, "accepted() %d", cnt);
 #endif
 
-		con = connections_get_new_connection(srv);
+    con = connections_get_new_connection(srv);
 
-		con->fd = cnt;
-		con->fdn = fdevent_register(srv->ev, con->fd, connection_handle_fdevent, con);
-		con->network_read = connection_read_cq;
-		con->network_write = connection_write_cq;
-		con->reqbody_read = h1_reqbody_read;
+    con->fd = cnt;
+    con->fdn = fdevent_register(srv->ev, con->fd, connection_handle_fdevent, con);
+    con->network_read = connection_read_cq;
+    con->network_write = connection_write_cq;
+    con->reqbody_read = h1_reqbody_read;
 
-		request_st * const r = &con->request;
-		connection_set_state(r, CON_STATE_REQUEST_START);
+    request_st *const r = &con->request;
+    connection_set_state(r, CON_STATE_REQUEST_START);
 
-		con->connection_start = log_monotonic_secs;
-		con->dst_addr = *cnt_addr;
-		sock_addr_cache_inet_ntop_copy_buffer(&con->dst_addr_buf,
-		                                      &con->dst_addr);
-		con->srv_socket = srv_socket;
-		con->is_ssl_sock = srv_socket->is_ssl;
-		con->proto_default_port = 80; /* "http" */
+    con->connection_start = log_monotonic_secs;
+    con->dst_addr = *cnt_addr;
+    sock_addr_cache_inet_ntop_copy_buffer(&con->dst_addr_buf,
+                                          &con->dst_addr);
+    con->srv_socket = srv_socket;
+    con->is_ssl_sock = srv_socket->is_ssl;
+    con->proto_default_port = 80; /* "http" */
 
-		config_cond_cache_reset(r);
-		r->conditional_is_valid = (1 << COMP_SERVER_SOCKET)
-		                        | (1 << COMP_HTTP_REMOTE_IP);
+    config_cond_cache_reset(r);
+    r->conditional_is_valid = (1 << COMP_SERVER_SOCKET) | (1 << COMP_HTTP_REMOTE_IP);
 
-		if (HANDLER_GO_ON != plugins_call_handle_connection_accept(con)) {
-			connection_reset(con);
-			connection_close(con);
-			return NULL;
-		}
-		if (r->http_status < 0) connection_set_state(r, CON_STATE_WRITE);
-		return con;
+    if (HANDLER_GO_ON != plugins_call_handle_connection_accept(con))
+    {
+        connection_reset(con);
+        connection_close(con);
+        return NULL;
+    }
+    if (r->http_status < 0)
+        connection_set_state(r, CON_STATE_WRITE);
+    return con;
 }
 
-
 __attribute_cold__
-__attribute_noinline__
-__attribute_nonnull__()
-static void
-connection_log_state (const request_st * const r, const char * const tag)
+    __attribute_noinline__
+    __attribute_nonnull__() static void connection_log_state(const request_st *const r, const char *const tag)
 {
-    buffer * const tb = r->tmp_buf;
+    buffer *const tb = r->tmp_buf;
     buffer_clear(tb);
     http_request_state_append(tb, r->state);
     log_error(r->conf.errh, __FILE__, __LINE__,
-      "fd:%d id:%d state:%s%s", r->con->fd, r->x.h2.id, tb->ptr, tag);
+              "fd:%d id:%d state:%s%s", r->con->fd, r->x.h2.id, tb->ptr, tag);
 }
 
-
 static void
-connection_state_machine_loop (request_st * const r, connection * const con)
-{
-	request_state_t ostate;
-	do {
-		if (r->conf.log_state_handling)
-			connection_log_state(r, "");
-
-		switch ((ostate = r->state)) {
-		case CON_STATE_REQUEST_START: /* transient */
-			/*(should not be reached by HTTP/2 streams)*/
-			connection_handle_request_start_state(r, con);
-			connection_set_state(r, CON_STATE_READ);
-			__attribute_fallthrough__
-		case CON_STATE_READ:
-			/*(should not be reached by HTTP/2 streams)*/
-			if (!h1_recv_headers(r, con)) {
-				if (r->http_version == HTTP_VERSION_2) {
-					connection_transition_h2(r, con);
-					connection_state_machine(con);
-					ostate = CON_STATE_WRITE;
-					continue; /*(end loop if CON_STATE_WRITE)*/
-				}
-				break;
-			}
-			/*connection_set_state(r, CON_STATE_REQUEST_END);*/
-			/*__attribute_fallthrough__*/
-		/*case CON_STATE_REQUEST_END:*//* transient */
-			connection_set_state(r,
-			  (0 == r->reqbody_length)
-			  ? CON_STATE_HANDLE_REQUEST
-			  : CON_STATE_READ_POST);
-			__attribute_fallthrough__
-		case CON_STATE_READ_POST:
-		case CON_STATE_HANDLE_REQUEST:
-			switch (http_response_handler(r)) {
-			  case HANDLER_GO_ON:/*CON_STATE_RESPONSE_START occurred;transient*/
-			  case HANDLER_FINISHED:
-				break;
-			  case HANDLER_WAIT_FOR_EVENT:
-				ostate = r->state;
-				continue; /*(end outer loop)*/
-			  /*case HANDLER_COMEBACK:*//*(not expected)*/
-			  /*case HANDLER_ERROR:*/
-			  default:
-				connection_set_state_error(r, CON_STATE_ERROR);
-				continue;
-			}
-			/*__attribute_fallthrough__*/
-		/*case CON_STATE_RESPONSE_START:*//*occurred;transient*/
-			h1_send_headers(r);
-			connection_set_state(r, CON_STATE_WRITE);
-			__attribute_fallthrough__
-		case CON_STATE_WRITE:
-			if (connection_handle_write_state(r, con) == CON_STATE_WRITE)
-				continue; /*(end outer loop)*/
-			__attribute_fallthrough__
-		case CON_STATE_RESPONSE_END: /* transient */
-		case CON_STATE_ERROR:        /* transient */
-			connection_handle_response_end_state(r, con);
-			/*(make sure ostate will not match r->state)*/
-			ostate = CON_STATE_RESPONSE_END;/* != r->state */
-			break;
-		case CON_STATE_CLOSE:
-			/*(should not be reached by HTTP/2 streams)*/
-			connection_handle_close_state(con);
-			break;
-		case CON_STATE_CONNECT:
-			break;
-		default:/*(should not happen)*/
-			/*connection_log_state(r, "");*/ /*(unknown state)*/
-			break;
-		}
-	} while (ostate != r->state);
-
+connection_state_machine_loop(request_st *const r, connection *const con)
+{
+    request_state_t ostate;
+    do
+    {
         if (r->conf.log_state_handling)
-            connection_log_state(r, " at loop exit");
-}
+            connection_log_state(r, "");
+
+        switch ((ostate = r->state))
+        {
+        case CON_STATE_REQUEST_START: /* transient */
+            /*(should not be reached by HTTP/2 streams)*/
+            connection_handle_request_start_state(r, con);
+            connection_set_state(r, CON_STATE_READ);
+        __attribute_fallthrough__ case CON_STATE_READ:
+            /*(should not be reached by HTTP/2 streams)*/
+            if (!h1_recv_headers(r, con))
+            {
+                if (r->http_version == HTTP_VERSION_2)
+                {
+                    connection_transition_h2(r, con);
+                    connection_state_machine(con);
+                    ostate = CON_STATE_WRITE;
+                    continue; /*(end loop if CON_STATE_WRITE)*/
+                }
+                break;
+            }
+            /*connection_set_state(r, CON_STATE_REQUEST_END);*/
+            /*__attribute_fallthrough__*/
+            /*case CON_STATE_REQUEST_END:*/ /* transient */
+            connection_set_state(r,
+                                 (0 == r->reqbody_length)
+                                     ? CON_STATE_HANDLE_REQUEST
+                                     : CON_STATE_READ_POST);
+        __attribute_fallthrough__ case CON_STATE_READ_POST:
+        case CON_STATE_HANDLE_REQUEST:
+            switch (http_response_handler(r))
+            {
+            case HANDLER_GO_ON: /*CON_STATE_RESPONSE_START occurred;transient*/
+            case HANDLER_FINISHED:
+                break;
+            case HANDLER_WAIT_FOR_EVENT:
+                ostate = r->state;
+                continue;              /*(end outer loop)*/
+            /*case HANDLER_COMEBACK:*/ /*(not expected)*/
+            /*case HANDLER_ERROR:*/
+            default:
+                connection_set_state_error(r, CON_STATE_ERROR);
+                continue;
+            }
+            /*__attribute_fallthrough__*/
+            /*case CON_STATE_RESPONSE_START:*/ /*occurred;transient*/
+            h1_send_headers(r);
+            connection_set_state(r, CON_STATE_WRITE);
+        __attribute_fallthrough__ case CON_STATE_WRITE:
+            if (connection_handle_write_state(r, con) == CON_STATE_WRITE)
+                continue;                                      /*(end outer loop)*/
+        __attribute_fallthrough__ case CON_STATE_RESPONSE_END: /* transient */
+        case CON_STATE_ERROR:                                  /* transient */
+            connection_handle_response_end_state(r, con);
+            /*(make sure ostate will not match r->state)*/
+            ostate = CON_STATE_RESPONSE_END; /* != r->state */
+            break;
+        case CON_STATE_CLOSE:
+            /*(should not be reached by HTTP/2 streams)*/
+            connection_handle_close_state(con);
+            break;
+        case CON_STATE_CONNECT:
+            break;
+        default:                             /*(should not happen)*/
+            /*connection_log_state(r, "");*/ /*(unknown state)*/
+            break;
+        }
+    } while (ostate != r->state);
 
+    if (r->conf.log_state_handling)
+        connection_log_state(r, " at loop exit");
+}
 
-__attribute_cold__
-static void
-connection_revents_err (request_st * const r, connection * const con)
+__attribute_cold__ static void
+connection_revents_err(request_st *const r, connection *const con)
 {
     /* defer handling FDEVENT_HUP and FDEVENT_ERR to here in order to
      * first attempt (in callers) to read data in kernel socket buffers */
@@ -749,24 +808,28 @@ connection_revents_err (request_st * const r, connection * const con)
     con->revents_err = 0;
 
     if (r->state == CON_STATE_CLOSE)
-        con->close_timeout_ts = log_monotonic_secs - (HTTP_LINGER_TIMEOUT+1);
+        con->close_timeout_ts = log_monotonic_secs - (HTTP_LINGER_TIMEOUT + 1);
     else if (revents & FDEVENT_HUP)
         connection_set_state_error(r, CON_STATE_ERROR);
-    else if (revents & FDEVENT_RDHUP) {
+    else if (revents & FDEVENT_RDHUP)
+    {
         int events = fdevent_fdnode_interest(con->fdn);
-        events &= ~(FDEVENT_IN|FDEVENT_RDHUP);
+        events &= ~(FDEVENT_IN | FDEVENT_RDHUP);
         r->conf.stream_request_body &=
-          ~(FDEVENT_STREAM_REQUEST_BUFMIN|FDEVENT_STREAM_REQUEST_POLLIN);
+            ~(FDEVENT_STREAM_REQUEST_BUFMIN | FDEVENT_STREAM_REQUEST_POLLIN);
         r->conf.stream_request_body |= FDEVENT_STREAM_REQUEST_POLLRDHUP;
         con->is_readable = 1; /*(can read 0 for end-of-stream)*/
-        if (chunkqueue_is_empty(con->read_queue)) r->keep_alive = 0;
-        if (r->reqbody_length < -1)/*(transparent proxy mode; no more rd data)*/
+        if (chunkqueue_is_empty(con->read_queue))
+            r->keep_alive = 0;
+        if (r->reqbody_length < -1) /*(transparent proxy mode; no more rd data)*/
             r->reqbody_length = r->reqbody_queue.bytes_in;
-        if (sock_addr_get_family(&con->dst_addr) == AF_UNIX) {
+        if (sock_addr_get_family(&con->dst_addr) == AF_UNIX)
+        {
             /* future: will getpeername() on AF_UNIX check if still connected?*/
             fdevent_fdnode_event_set(con->srv->ev, con->fdn, events);
         }
-        else if (fdevent_is_tcp_half_closed(con->fd)) {
+        else if (fdevent_is_tcp_half_closed(con->fd))
+        {
             /* Success of fdevent_is_tcp_half_closed() after FDEVENT_RDHUP
              * indicates TCP FIN received, but does not distinguish between
              * client shutdown(fd, SHUT_WR) and client close(fd).  Remove
@@ -779,27 +842,29 @@ connection_revents_err (request_st * const r, connection * const con)
             r->conf.stream_request_body |= FDEVENT_STREAM_REQUEST_TCP_FIN;
             fdevent_fdnode_event_set(con->srv->ev, con->fdn, events);
         }
-        else {
+        else
+        {
             /* Failure of fdevent_is_tcp_half_closed() indicates TCP RST
              * (or unable to tell (unsupported OS), though should not
              * be setting FDEVENT_RDHUP in that case) */
             connection_set_state_error(r, CON_STATE_ERROR);
         }
     }
-    else if (revents & FDEVENT_ERR)  /* error, connection reset */
+    else if (revents & FDEVENT_ERR) /* error, connection reset */
         connection_set_state_error(r, CON_STATE_ERROR);
     else
         log_error(r->conf.errh, __FILE__, __LINE__,
-          "connection closed: poll() -> ??? %d", revents);
+                  "connection closed: poll() -> ??? %d", revents);
 }
 
-
 static void
-connection_set_fdevent_interest (request_st * const r, connection * const con)
+connection_set_fdevent_interest(request_st *const r, connection *const con)
 {
-    if (con->fd < 0) return;
+    if (con->fd < 0)
+        return;
 
-    if (con->revents_err && r->state != CON_STATE_ERROR) {
+    if (con->revents_err && r->state != CON_STATE_ERROR)
+    {
         connection_revents_err(r, con); /* resets con->revents_err = 0 */
         connection_state_machine(con);
         return;
@@ -808,45 +873,47 @@ connection_set_fdevent_interest (request_st * const r, connection * const con)
     }
 
     int n = 0;
-    switch(r->state) {
-      case CON_STATE_READ:
+    switch (r->state)
+    {
+    case CON_STATE_READ:
         n = FDEVENT_IN;
         if (!(r->conf.stream_request_body & FDEVENT_STREAM_REQUEST_POLLRDHUP))
             n |= FDEVENT_RDHUP;
         break;
-      case CON_STATE_WRITE:
-        if (!chunkqueue_is_empty(con->write_queue)
-            && 0 == con->is_writable && 0 == con->traffic_limit_reached)
+    case CON_STATE_WRITE:
+        if (!chunkqueue_is_empty(con->write_queue) && 0 == con->is_writable && 0 == con->traffic_limit_reached)
             n |= FDEVENT_OUT;
-        __attribute_fallthrough__
-      case CON_STATE_READ_POST:
+    __attribute_fallthrough__ case CON_STATE_READ_POST:
         if (r->conf.stream_request_body & FDEVENT_STREAM_REQUEST_POLLIN)
             n |= FDEVENT_IN;
         if (!(r->conf.stream_request_body & FDEVENT_STREAM_REQUEST_POLLRDHUP))
             n |= FDEVENT_RDHUP;
         break;
-      case CON_STATE_CLOSE:
+    case CON_STATE_CLOSE:
         n = FDEVENT_IN;
         break;
-      case CON_STATE_CONNECT:
+    case CON_STATE_CONNECT:
         return;
-      default:
+    default:
         break;
     }
 
     const int events = fdevent_fdnode_interest(con->fdn);
-    if (con->is_readable < 0) {
+    if (con->is_readable < 0)
+    {
         con->is_readable = 0;
         n |= FDEVENT_IN;
     }
-    if (con->is_writable < 0) {
+    if (con->is_writable < 0)
+    {
         con->is_writable = 0;
         n |= FDEVENT_OUT;
     }
     if (events & FDEVENT_RDHUP)
         n |= FDEVENT_RDHUP;
 
-    if (n == events) return;
+    if (n == events)
+        return;
 
     /* update timestamps when enabling interest in events */
     if ((n & FDEVENT_IN) && !(events & FDEVENT_IN))
@@ -856,26 +923,23 @@ connection_set_fdevent_interest (request_st * const r, connection * const con)
     fdevent_fdnode_event_set(con->srv->ev, con->fdn, n);
 }
 
-
-void
-connection_state_machine (connection * const con)
+void connection_state_machine(connection *const con)
 {
     int rc = !con->fn || con->fn->process_streams(con, http_response_handler,
-                                                       connection_handle_write);
-    request_st * const r = &con->request;
+                                                  connection_handle_write);
+    request_st *const r = &con->request;
     if (rc)
         connection_state_machine_loop(r, con);
     connection_set_fdevent_interest(r, con);
 }
 
-
 static void
-connection_check_timeout (connection * const con, const unix_time64_t cur_ts)
+connection_check_timeout(connection *const con, const unix_time64_t cur_ts)
 {
     int changed = (con->fn && con->fn->check_timeout)
-      ? con->fn->check_timeout(con, cur_ts)
-      : h1_check_timeout(con, cur_ts);
-      /*http_dispatch[HTTP_VERSION_1_1].check_timeout(con, cur_ts)*//*(future)*/
+                      ? con->fn->check_timeout(con, cur_ts)
+                      : h1_check_timeout(con, cur_ts);
+    /*http_dispatch[HTTP_VERSION_1_1].check_timeout(con, cur_ts)*/ /*(future)*/
 
     con->bytes_written_cur_second = 0;
 
@@ -883,46 +947,46 @@ connection_check_timeout (connection * const con, const unix_time64_t cur_ts)
      * (currently) taken only from top-level config (socket), with host if SNI
      * used, but not any other config conditions, e.g. not per-file-type */
 
-    if (__builtin_expect( (con->traffic_limit_reached != 0), 0)) {
-        const request_st * const r = &con->request;
+    if (__builtin_expect((con->traffic_limit_reached != 0), 0))
+    {
+        const request_st *const r = &con->request;
         const int t_diff = cur_ts - con->connection_start;
-        if (r->conf.bytes_per_second == 0
-            || con->write_queue->bytes_out
-                 < (off_t)r->conf.bytes_per_second * (t_diff ? t_diff : 1)) {
+        if (r->conf.bytes_per_second == 0 || con->write_queue->bytes_out < (off_t)r->conf.bytes_per_second * (t_diff ? t_diff : 1))
+        {
             /* enable connection write again */
             con->traffic_limit_reached = 0;
             changed = 1;
         }
     }
 
-    if (changed) {
+    if (changed)
+    {
         connection_state_machine(con);
     }
 }
 
-
-void
-connection_periodic_maint (server * const srv, const unix_time64_t cur_ts)
+void connection_periodic_maint(server *const srv, const unix_time64_t cur_ts)
 {
     /* check all connections for timeouts */
-    for (connection *con = srv->conns, *tc; con; con = tc) {
+    for (connection *con = srv->conns, *tc; con; con = tc)
+    {
         tc = con->next;
         connection_check_timeout(con, cur_ts);
     }
 }
 
-
-void
-connection_graceful_shutdown_maint (server * const srv)
+void connection_graceful_shutdown_maint(server *const srv)
 {
     const int graceful_expire =
-      (srv->graceful_expire_ts && srv->graceful_expire_ts < log_monotonic_secs);
-    for (connection *con = srv->conns, *tc; con; con = tc) {
+        (srv->graceful_expire_ts && srv->graceful_expire_ts < log_monotonic_secs);
+    for (connection *con = srv->conns, *tc; con; con = tc)
+    {
         tc = con->next;
         int changed = 0;
 
-        request_st * const r = &con->request;
-        if (r->state == CON_STATE_CLOSE) {
+        request_st *const r = &con->request;
+        if (r->state == CON_STATE_CLOSE)
+        {
             /* reduce remaining linger timeout to be
              * (from zero) *up to* one more second, but no more */
             if (HTTP_LINGER_TIMEOUT > 1)
@@ -930,32 +994,36 @@ connection_graceful_shutdown_maint (server * const srv)
             if (log_monotonic_secs - con->close_timeout_ts > HTTP_LINGER_TIMEOUT)
                 changed = 1;
         }
-        else if (con->fn) {
+        else if (con->fn)
+        {
             if (con->fn->goaway_graceful(con))
                 changed = 1;
         }
-        else if (r->state == CON_STATE_READ && con->request_count > 1
-                 && chunkqueue_is_empty(con->read_queue)) {
+        else if (r->state == CON_STATE_READ && con->request_count > 1 && chunkqueue_is_empty(con->read_queue))
+        {
             /* close connections in keep-alive waiting for next request */
             connection_set_state_error(r, CON_STATE_ERROR);
             changed = 1;
         }
 
-        if (graceful_expire) {
+        if (graceful_expire)
+        {
             connection_set_state_error(r, CON_STATE_ERROR);
             changed = 1;
         }
 
-        r->keep_alive = 0;            /* disable keep-alive */
+        r->keep_alive = 0; /* disable keep-alive */
 
-        r->conf.bytes_per_second = 0;         /* disable rate limit */
-        r->conf.global_bytes_per_second = 0;  /* disable rate limit */
-        if (con->traffic_limit_reached) {
+        r->conf.bytes_per_second = 0;        /* disable rate limit */
+        r->conf.global_bytes_per_second = 0; /* disable rate limit */
+        if (con->traffic_limit_reached)
+        {
             con->traffic_limit_reached = 0;
             changed = 1;
         }
 
-        if (changed) {
+        if (changed)
+        {
             connection_state_machine(con);
         }
     }
diff --git a/src/h1.c b/src/h1.c
index eabcb414..d018a6a4 100644
--- a/src/h1.c
+++ b/src/h1.c
@@ -13,22 +13,21 @@
 #include "base.h"
 #include "buffer.h"
 #include "chunk.h"
-#include "fdevent.h"    /* FDEVENT_STREAM_REQUEST_BUFMIN */
+#include "fdevent.h" /* FDEVENT_STREAM_REQUEST_BUFMIN */
 #include "http_date.h"
 #include "http_header.h"
 #include "log.h"
-#include "reqpool.h"    /* request_reset_ex() */
+#include "reqpool.h" /* request_reset_ex() */
 #include "request.h"
-#include "response.h"   /* http_response_reqbody_read_error() */
-
+#include "response.h" /* http_response_reqbody_read_error() */
 
 static int
-h1_send_1xx_info (request_st * const r, connection * const con)
+h1_send_1xx_info(request_st *const r, connection *const con)
 {
     /* (Note: prior 1xx intermediate responses may be present in cq) */
     /* (Note: also choosing not to update con->write_request_ts
      *  which differs from connection_write_chunkqueue()) */
-    chunkqueue * const cq = con->write_queue;
+    chunkqueue *const cq = con->write_queue;
     off_t written = cq->bytes_out;
 
     int rc = con->network_write(con, cq, MAX_WRITE_LIMIT);
@@ -38,14 +37,17 @@ h1_send_1xx_info (request_st * const r, connection * const con)
     if (r->conf.global_bytes_per_second_cnt_ptr)
         *(r->conf.global_bytes_per_second_cnt_ptr) += written;
 
-    if (rc < 0) {
+    if (rc < 0)
+    {
         request_set_state_error(r, CON_STATE_ERROR);
         return 0; /* error */
     }
 
-    if (!chunkqueue_is_empty(cq)) { /* partial write (unlikely) */
+    if (!chunkqueue_is_empty(cq))
+    { /* partial write (unlikely) */
         con->is_writable = 0;
-        if (cq == &r->write_queue) {
+        if (cq == &r->write_queue)
+        {
             /* save partial write of 1xx in separate chunkqueue
              * Note: sending of remainder of 1xx might be delayed
              * until next set of response headers are sent */
@@ -57,7 +59,7 @@ h1_send_1xx_info (request_st * const r, connection * const con)
         }
     }
 
-  #if 0
+#if 0
     /* XXX: accounting inconsistency
      * 1xx is not currently included in r->resp_header_len,
      * so mod_accesslog reporting of %b or %B (FORMAT_BYTES_OUT_NO_HEADER)
@@ -69,15 +71,13 @@ h1_send_1xx_info (request_st * const r, connection * const con)
      * (Doing the following would "discard" the 1xx len from bytes_out)
      */
     r->write_queue.bytes_in = r->write_queue.bytes_out = 0;
-  #endif
+#endif
 
     return 1; /* success */
 }
 
-
-__attribute_cold__
-int
-h1_send_1xx (request_st * const r, connection * const con)
+__attribute_cold__ int
+h1_send_1xx(request_st *const r, connection *const con)
 {
     /* Make best effort to send HTTP/1.1 1xx intermediate */
     /* (Note: if other modules set response headers *before* the
@@ -87,16 +87,18 @@ h1_send_1xx (request_st * const r, connection * const con)
      *  instead of being sent with the final response.
      *  (e.g. mod_magnet setting response headers, then backend sending 103)) */
 
-    chunkqueue * const cq = con->write_queue; /*(bypass r->write_queue)*/
+    chunkqueue *const cq = con->write_queue; /*(bypass r->write_queue)*/
 
-    buffer * const b = chunkqueue_append_buffer_open(cq);
+    buffer *const b = chunkqueue_append_buffer_open(cq);
     buffer_copy_string_len(b, CONST_STR_LEN("HTTP/1.1 "));
     http_status_append(b, r->http_status);
-    for (uint32_t i = 0; i < r->resp_headers.used; ++i) {
-        const data_string * const ds = (data_string *)r->resp_headers.data[i];
+    for (uint32_t i = 0; i < r->resp_headers.used; ++i)
+    {
+        const data_string *const ds = (data_string *)r->resp_headers.data[i];
         const uint32_t klen = buffer_clen(&ds->key);
         const uint32_t vlen = buffer_clen(&ds->value);
-        if (0 == klen || 0 == vlen) continue;
+        if (0 == klen || 0 == vlen)
+            continue;
         buffer_append_str2(b, CONST_STR_LEN("\r\n"), ds->key.ptr, klen);
         buffer_append_str2(b, CONST_STR_LEN(": "), ds->value.ptr, vlen);
     }
@@ -109,9 +111,8 @@ h1_send_1xx (request_st * const r, connection * const con)
     return h1_send_1xx_info(r, con);
 }
 
-
 static int
-h1_send_100_continue (request_st * const r, connection * const con)
+h1_send_100_continue(request_st *const r, connection *const con)
 {
     /* Make best effort to send "HTTP/1.1 100 Continue" */
     static const char http_100_continue[] = "HTTP/1.1 100 Continue\r\n\r\n";
@@ -119,111 +120,109 @@ h1_send_100_continue (request_st * const r, connection * const con)
     if (con->traffic_limit_reached)
         return 1; /* success; skip sending if throttled */
 
-    chunkqueue * const cq = con->write_queue; /*(bypass r->write_queue)*/
-    chunkqueue_append_mem(cq, http_100_continue, sizeof(http_100_continue)-1);
+    chunkqueue *const cq = con->write_queue; /*(bypass r->write_queue)*/
+    chunkqueue_append_mem(cq, http_100_continue, sizeof(http_100_continue) - 1);
     return h1_send_1xx_info(r, con);
 }
 
-
-__attribute_cold__
-static void
-h1_send_headers_partial_1xx (request_st * const r, buffer * const b)
+__attribute_cold__ static void
+h1_send_headers_partial_1xx(request_st *const r, buffer *const b)
 {
     /* take data in con->write_queue and move into b
      * (to be sent prior to final response headers in r->write_queue) */
-    connection * const con = r->con;
+    connection *const con = r->con;
     /*assert(&r->write_queue != con->write_queue);*/
-    chunkqueue * const cq = con->write_queue;
+    chunkqueue *const cq = con->write_queue;
     con->write_queue = &r->write_queue;
 
-    /*assert(0 == buffer_clen(b));*//*expect empty buffer from caller*/
+    /*assert(0 == buffer_clen(b));*/ /*expect empty buffer from caller*/
     uint32_t len = (uint32_t)chunkqueue_length(cq);
     /*(expecting MEM_CHUNK(s), so not expecting error reading files)*/
     if (chunkqueue_read_data(cq, buffer_string_prepare_append(b, len),
                              len, r->conf.errh) < 0)
         len = 0;
-    buffer_truncate(b, len);/*expect initial empty buffer from caller*/
+    buffer_truncate(b, len); /*expect initial empty buffer from caller*/
     chunkqueue_free(cq);
 }
 
-
-void
-h1_send_headers (request_st * const r)
+void h1_send_headers(request_st *const r)
 {
     /* disable keep-alive if requested */
 
     r->con->keep_alive_idle = r->conf.max_keep_alive_idle;
-    if (__builtin_expect( (0 == r->conf.max_keep_alive_idle), 0)
-        || r->con->request_count > r->conf.max_keep_alive_requests) {
+    if (__builtin_expect((0 == r->conf.max_keep_alive_idle), 0) || r->con->request_count > r->conf.max_keep_alive_requests)
+    {
         r->keep_alive = 0;
     }
-    else if (0 != r->reqbody_length
-             && r->reqbody_length != r->reqbody_queue.bytes_in
-             && (NULL == r->handler_module
-                 || 0 == (r->conf.stream_request_body
-                          & (FDEVENT_STREAM_REQUEST
-                             | FDEVENT_STREAM_REQUEST_BUFMIN)))) {
+    else if (0 != r->reqbody_length && r->reqbody_length != r->reqbody_queue.bytes_in && (NULL == r->handler_module || 0 == (r->conf.stream_request_body & (FDEVENT_STREAM_REQUEST | FDEVENT_STREAM_REQUEST_BUFMIN))))
+    {
         r->keep_alive = 0;
     }
 
-    if (light_btst(r->resp_htags, HTTP_HEADER_UPGRADE)
-        && r->http_version == HTTP_VERSION_1_1) {
+    if (light_btst(r->resp_htags, HTTP_HEADER_UPGRADE) && r->http_version == HTTP_VERSION_1_1)
+    {
         http_header_response_set(r, HTTP_HEADER_CONNECTION,
                                  CONST_STR_LEN("Connection"),
                                  CONST_STR_LEN("upgrade"));
     }
-    else if (r->keep_alive <= 0) {
+    else if (r->keep_alive <= 0)
+    {
         if (r->keep_alive < 0)
             http_response_delay(r->con);
         http_header_response_set(r, HTTP_HEADER_CONNECTION,
                                  CONST_STR_LEN("Connection"),
                                  CONST_STR_LEN("close"));
     }
-    else if (r->http_version == HTTP_VERSION_1_0) {/*(&& r->keep_alive > 0)*/
+    else if (r->http_version == HTTP_VERSION_1_0)
+    { /*(&& r->keep_alive > 0)*/
         http_header_response_set(r, HTTP_HEADER_CONNECTION,
                                  CONST_STR_LEN("Connection"),
                                  CONST_STR_LEN("keep-alive"));
     }
 
-    if (304 == r->http_status
-        && light_btst(r->resp_htags, HTTP_HEADER_CONTENT_ENCODING)) {
+    if (304 == r->http_status && light_btst(r->resp_htags, HTTP_HEADER_CONTENT_ENCODING))
+    {
         http_header_response_unset(r, HTTP_HEADER_CONTENT_ENCODING,
                                    CONST_STR_LEN("Content-Encoding"));
     }
 
-    chunkqueue * const cq = &r->write_queue;
-    buffer * const b = chunkqueue_prepend_buffer_open(cq);
+    chunkqueue *const cq = &r->write_queue;
+    buffer *const b = chunkqueue_prepend_buffer_open(cq);
 
     if (cq != r->con->write_queue)
         h1_send_headers_partial_1xx(r, b);
 
     buffer_append_string_len(b,
                              (r->http_version == HTTP_VERSION_1_1)
-                               ? "HTTP/1.1 "
-                               : "HTTP/1.0 ",
-                             sizeof("HTTP/1.1 ")-1);
+                                 ? "HTTP/1.1 "
+                                 : "HTTP/1.0 ",
+                             sizeof("HTTP/1.1 ") - 1);
     http_status_append(b, r->http_status);
 
     /* add all headers */
-    for (size_t i = 0, used = r->resp_headers.used; i < used; ++i) {
-        const data_string * const ds = (data_string *)r->resp_headers.data[i];
+    for (size_t i = 0, used = r->resp_headers.used; i < used; ++i)
+    {
+        const data_string *const ds = (data_string *)r->resp_headers.data[i];
         const uint32_t klen = buffer_clen(&ds->key);
         const uint32_t vlen = buffer_clen(&ds->value);
-        if (__builtin_expect( (0 == klen), 0)) continue;
-        if (__builtin_expect( (0 == vlen), 0)) continue;
+        if (__builtin_expect((0 == klen), 0))
+            continue;
+        if (__builtin_expect((0 == vlen), 0))
+            continue;
         if ((ds->key.ptr[0] & 0xdf) == 'X' && http_response_omit_header(r, ds))
             continue;
-        char * restrict s = buffer_extend(b, klen+vlen+4);
+        char *restrict s = buffer_extend(b, klen + vlen + 4);
         s[0] = '\r';
         s[1] = '\n';
-        memcpy(s+2, ds->key.ptr, klen);
-        s += 2+klen;
+        memcpy(s + 2, ds->key.ptr, klen);
+        s += 2 + klen;
         s[0] = ':';
         s[1] = ' ';
-        memcpy(s+2, ds->value.ptr, vlen);
+        memcpy(s + 2, ds->value.ptr, vlen);
     }
 
-    if (!light_btst(r->resp_htags, HTTP_HEADER_DATE)) {
+    if (!light_btst(r->resp_htags, HTTP_HEADER_DATE))
+    {
         /* HTTP/1.1 and later requires a Date: header */
         /* "\r\nDate: " 8-chars + 30-chars "%a, %d %b %Y %T GMT" + '\0' */
         static unix_time64_t tlast = 0;
@@ -231,15 +230,15 @@ h1_send_headers (request_st * const r)
 
         /* cache the generated timestamp */
         const unix_time64_t cur_ts = log_epoch_secs;
-        if (__builtin_expect ( (tlast != cur_ts), 0))
-            http_date_time_to_str(tstr+8, sizeof(tstr)-8, (tlast = cur_ts));
+        if (__builtin_expect((tlast != cur_ts), 0))
+            http_date_time_to_str(tstr + 8, sizeof(tstr) - 8, (tlast = cur_ts));
 
         buffer_append_string_len(b, tstr, 37);
     }
 
     if (!light_btst(r->resp_htags, HTTP_HEADER_SERVER) && r->conf.server_tag)
         buffer_append_str2(b, CONST_STR_LEN("\r\nServer: "),
-                              BUF_PTR_LEN(r->conf.server_tag));
+                           BUF_PTR_LEN(r->conf.server_tag));
 
     buffer_append_string_len(b, CONST_STR_LEN("\r\n\r\n"));
     r->resp_header_len = buffer_clen(b);
@@ -252,46 +251,44 @@ h1_send_headers (request_st * const r)
 
     /*(optimization to use fewer syscalls to send a small response)*/
     off_t cqlen;
-    if (r->resp_body_finished
-        && light_btst(r->resp_htags, HTTP_HEADER_CONTENT_LENGTH)
-        && (cqlen = chunkqueue_length(cq) - r->resp_header_len) > 0
-        && cqlen < 16384)
+    if (r->resp_body_finished && light_btst(r->resp_htags, HTTP_HEADER_CONTENT_LENGTH) && (cqlen = chunkqueue_length(cq) - r->resp_header_len) > 0 && cqlen < 16384)
         chunkqueue_small_resp_optim(cq);
 }
 
-
-__attribute_cold__
-static chunk *
-h1_discard_blank_line (chunkqueue * const cq, uint32_t header_len)
+__attribute_cold__ static chunk *
+h1_discard_blank_line(chunkqueue *const cq, uint32_t header_len)
 {
     /*(separate func only to be able to mark with compiler hint as cold)*/
     chunkqueue_mark_written(cq, header_len);
     return cq->first; /* refresh c after chunkqueue_mark_written() */
 }
 
-
 static chunk *
-h1_recv_headers_more (connection * const con, chunkqueue * const cq, chunk *c, const size_t olen)
+h1_recv_headers_more(connection *const con, chunkqueue *const cq, chunk *c, const size_t olen)
 {
     /*(should not be reached by HTTP/2 streams)*/
     /*if (r->http_version == HTTP_VERSION_2) return NULL;*/
     /*(However, new connections over TLS may become HTTP/2 connections via ALPN
      * and return from this routine with r->http_version == HTTP_VERSION_2) */
 
-    if ((NULL == c || NULL == c->next) && con->is_readable > 0) {
+    if ((NULL == c || NULL == c->next) && con->is_readable > 0)
+    {
         con->read_idle_ts = log_monotonic_secs;
-        if (0 != con->network_read(con, cq, MAX_READ_LIMIT)) {
-            request_st * const r = &con->request;
+        if (0 != con->network_read(con, cq, MAX_READ_LIMIT))
+        {
+            request_st *const r = &con->request;
             request_set_state_error(r, CON_STATE_ERROR);
         }
         /* check if switched to HTTP/2 (ALPN "h2" during TLS negotiation) */
-        request_st * const r = &con->request;
-        if (r->http_version == HTTP_VERSION_2) return NULL;
+        request_st *const r = &con->request;
+        if (r->http_version == HTTP_VERSION_2)
+            return NULL;
     }
 
-    if (cq->first != cq->last && 0 != olen) {
+    if (cq->first != cq->last && 0 != olen)
+    {
         const size_t clen = chunkqueue_length(cq);
-        size_t block = (olen + (16384-1)) & ~(16384-1);
+        size_t block = (olen + (16384 - 1)) & ~(16384 - 1);
         block += (block - olen > 1024 ? 0 : 16384);
         chunkqueue_compact_mem(cq, block > clen ? clen : block);
     }
@@ -299,33 +296,34 @@ h1_recv_headers_more (connection * const con, chunkqueue * const cq, chunk *c, c
     /* detect if data is added to chunk */
     c = cq->first;
     return (c && (size_t)c->offset + olen < buffer_clen(c->mem))
-      ? c
-      : NULL;
+               ? c
+               : NULL;
 }
 
-
 #include "plugin_config.h" /* COMP_SERVER_SOCKET COMP_HTTP_REMOTE_IP */
 
-__attribute_cold__
-static int
-h1_check_upgrade (request_st * const r, connection * const con)
+__attribute_cold__ static int
+h1_check_upgrade(request_st *const r, connection *const con)
 {
     buffer *upgrade = http_header_request_get(r, HTTP_HEADER_UPGRADE,
                                               CONST_STR_LEN("Upgrade"));
-  #ifdef __COVERITY__
-    if (NULL == upgrade) return 0; /*(checked by caller)*/
-  #endif
-
-    buffer * const http_connection =
-      http_header_request_get(r, HTTP_HEADER_CONNECTION,
-                              CONST_STR_LEN("Connection"));
-    if (NULL == http_connection) {
+#ifdef __COVERITY__
+    if (NULL == upgrade)
+        return 0; /*(checked by caller)*/
+#endif
+
+    buffer *const http_connection =
+        http_header_request_get(r, HTTP_HEADER_CONNECTION,
+                                CONST_STR_LEN("Connection"));
+    if (NULL == http_connection)
+    {
         http_header_request_unset(r, HTTP_HEADER_UPGRADE,
                                   CONST_STR_LEN("Upgrade"));
         return 0;
     }
 
-    if (r->http_version == HTTP_VERSION_1_1) {
+    if (r->http_version == HTTP_VERSION_1_1)
+    {
         /* Upgrade: websocket (not handled here)
          * (potentially handled by modules elsewhere) */
 
@@ -337,7 +335,8 @@ h1_check_upgrade (request_st * const r, connection * const con)
          * RFC7540 3.2 Starting HTTP/2 for "http" URIs */
 
         if (http_header_str_contains_token(BUF_PTR_LEN(http_connection),
-                                           CONST_STR_LEN("HTTP2-Settings"))) {
+                                           CONST_STR_LEN("HTTP2-Settings")))
+        {
             if (http_dispatch[HTTP_VERSION_2].upgrade_h2c)
                 http_dispatch[HTTP_VERSION_2].upgrade_h2c(r, con);
         } /*else ignore Upgrade: h2c; HTTP2-Settings required for Upgrade: h2c*/
@@ -356,17 +355,14 @@ h1_check_upgrade (request_st * const r, connection * const con)
         return 0;
 
     /*(Upgrade: h2c over cleartext does not have SNI; no COMP_HTTP_HOST)*/
-    r->conditional_is_valid = (1 << COMP_SERVER_SOCKET)
-                            | (1 << COMP_HTTP_REMOTE_IP);
-    /*connection_handle_write(r, con);*//* defer write to network */
+    r->conditional_is_valid = (1 << COMP_SERVER_SOCKET) | (1 << COMP_HTTP_REMOTE_IP);
+    /*connection_handle_write(r, con);*/ /* defer write to network */
     return 1;
 }
 
-
-int
-h1_recv_headers (request_st * const r, connection * const con)
+int h1_recv_headers(request_st *const r, connection *const con)
 {
-    chunkqueue * const cq = con->read_queue;
+    chunkqueue *const cq = con->read_queue;
     chunk *c = cq->first;
     uint32_t clen = 0;
     uint32_t header_len = 0;
@@ -375,11 +371,14 @@ h1_recv_headers (request_st * const r, connection * const con)
     uint8_t discard_blank = 0;
     unsigned short hoff[8192]; /* max num header lines + 3; 16k on stack */
 
-    if (con->request_count > 1) {
+    if (con->request_count > 1)
+    {
         discard_blank = 1;
-        if (cq->bytes_in == r->x.h1.bytes_read_ckpt) {
+        if (cq->bytes_in == r->x.h1.bytes_read_ckpt)
+        {
             keepalive_request_start = 1;
-            if (NULL != c) { /* !chunkqueue_is_empty(cq)) */
+            if (NULL != c)
+            { /* !chunkqueue_is_empty(cq)) */
                 pipelined_request_start = 1;
                 /* partial header of next request has already been read,
                  * so optimistically check for more data received on
@@ -391,25 +390,28 @@ h1_recv_headers (request_st * const r, connection * const con)
         }
     }
 
-    do {
-        if (NULL == c) continue;
+    do
+    {
+        if (NULL == c)
+            continue;
         clen = buffer_clen(c->mem) - c->offset;
-        if (0 == clen) continue;
-        if (__builtin_expect( (c->offset > USHRT_MAX), 0)) /*(highly unlikely)*/
+        if (0 == clen)
+            continue;
+        if (__builtin_expect((c->offset > USHRT_MAX), 0)) /*(highly unlikely)*/
             chunkqueue_compact_mem_offset(cq);
 
         hoff[0] = 1;                         /* number of lines */
         hoff[1] = (unsigned short)c->offset; /* base offset for all lines */
         /*hoff[2] = ...;*/                   /* offset from base for 2nd line */
 
-        header_len = http_header_parse_hoff(c->mem->ptr + c->offset,clen,hoff);
+        header_len = http_header_parse_hoff(c->mem->ptr + c->offset, clen, hoff);
 
         /* casting to (unsigned short) might truncate, and the hoff[]
          * addition might overflow, but max_request_field_size is USHRT_MAX,
          * so failure will be detected below */
         const uint32_t max_request_field_size = r->conf.max_request_field_size;
-        if ((header_len ? header_len : clen) > max_request_field_size
-            || hoff[0] >= sizeof(hoff)/sizeof(hoff[0])-1) {
+        if ((header_len ? header_len : clen) > max_request_field_size || hoff[0] >= sizeof(hoff) / sizeof(hoff[0]) - 1)
+        {
             log_error(r->conf.errh, __FILE__, __LINE__, "%s",
                       "oversized request-header -> sending Status 431");
             r->http_status = 431; /* Request Header Fields Too Large */
@@ -417,40 +419,49 @@ h1_recv_headers (request_st * const r, connection * const con)
             return 1;
         }
 
-        if (__builtin_expect( (0 != header_len), 1)) {
-            if (__builtin_expect( (hoff[0] > 1), 1))
+        if (__builtin_expect((0 != header_len), 1))
+        {
+            if (__builtin_expect((hoff[0] > 1), 1))
                 break; /* common case; request headers complete */
 
-            if (discard_blank) { /* skip one blank line e.g. following POST */
-                if (header_len == clen) continue;
-                const int ch = c->mem->ptr[c->offset+header_len];
-                if (ch != '\r' && ch != '\n') {
+            if (discard_blank)
+            { /* skip one blank line e.g. following POST */
+                if (header_len == clen)
+                    continue;
+                const int ch = c->mem->ptr[c->offset + header_len];
+                if (ch != '\r' && ch != '\n')
+                {
                     /* discard prior blank line if next line is not blank */
                     discard_blank = 0;
-                    clen = 0;/*(for h1_recv_headers_more() to return c)*/
-                    c = h1_discard_blank_line(cq, header_len);/*cold*/
+                    clen = 0;                                  /*(for h1_recv_headers_more() to return c)*/
+                    c = h1_discard_blank_line(cq, header_len); /*cold*/
                     continue;
                 } /*(else fall through to error out in next block)*/
             }
         }
 
-        if (((unsigned char *)c->mem->ptr)[c->offset] < 32) {
+        if (((unsigned char *)c->mem->ptr)[c->offset] < 32)
+        {
             /* expecting ASCII method beginning with alpha char
              * or HTTP/2 pseudo-header beginning with ':' */
             /*(TLS handshake begins with SYN 0x16 (decimal 22))*/
             log_error(r->conf.errh, __FILE__, __LINE__, "%s (%s)",
                       c->mem->ptr[c->offset] == 0x16
-                      ? "unexpected TLS ClientHello on clear port"
-                      : "invalid request-line -> sending Status 400",
+                          ? "unexpected TLS ClientHello on clear port"
+                          : "invalid request-line -> sending Status 400",
                       con->dst_addr_buf.ptr);
             r->http_status = 400; /* Bad Request */
             r->keep_alive = 0;
+
+            chunkqueue_reset(cq); // LEO ADDING: reset the chunkqueue
             return 1;
         }
     } while ((c = h1_recv_headers_more(con, cq, c, clen)));
 
-    if (keepalive_request_start) {
-        if (cq->bytes_in > r->x.h1.bytes_read_ckpt) {
+    if (keepalive_request_start)
+    {
+        if (cq->bytes_in > r->x.h1.bytes_read_ckpt)
+        {
             /* update r->start_hp.tv_sec timestamp when first byte of
              * next request is received on a keep-alive connection */
             r->start_hp.tv_sec = log_epoch_secs;
@@ -461,17 +472,20 @@ h1_recv_headers (request_st * const r, connection * const con)
             con->read_idle_ts = log_monotonic_secs;
     }
 
-    if (NULL == c) return 0; /* incomplete request headers */
+    if (NULL == c)
+        return 0; /* incomplete request headers */
 
-  #ifdef __COVERITY__
-    if (buffer_clen(c->mem) < hoff[1]) {
+#ifdef __COVERITY__
+    if (buffer_clen(c->mem) < hoff[1])
+    {
         return 1;
     }
-  #endif
+#endif
 
-    char * const hdrs = c->mem->ptr + hoff[1];
+    char *const hdrs = c->mem->ptr + hoff[1];
 
-    if (con->request_count > 1) {
+    if (con->request_count > 1)
+    {
         /* adjust r->x.h1.bytes_read_ckpt for http_request_stats_bytes_in()
          * (headers_len is still in cq; marked written, bytes_out incr below) */
         r->x.h1.bytes_read_ckpt = cq->bytes_out;
@@ -485,9 +499,8 @@ h1_recv_headers (request_st * const r, connection * const con)
      * If ALT-SVC used to advertise HTTP/2, then client might start
      * http connection (not TLS) sending HTTP/2 connection preface.
      * (note: intentionally checking only on initial request) */
-    else if (!con->is_ssl_sock && r->conf.h2proto
-             && hoff[0] == 2 && hoff[2] == 16
-             && hdrs[0]=='P' && hdrs[1]=='R' && hdrs[2]=='I' && hdrs[3]==' ') {
+    else if (!con->is_ssl_sock && r->conf.h2proto && hoff[0] == 2 && hoff[2] == 16 && hdrs[0] == 'P' && hdrs[1] == 'R' && hdrs[2] == 'I' && hdrs[3] == ' ')
+    {
         r->http_version = HTTP_VERSION_2;
         return 0;
     }
@@ -499,25 +512,21 @@ h1_recv_headers (request_st * const r, connection * const con)
     http_request_headers_process(r, hdrs, hoff, con->proto_default_port);
     chunkqueue_mark_written(cq, r->rqst_header_len);
 
-    if (light_btst(r->rqst_htags, HTTP_HEADER_UPGRADE)
-        && 0 == r->http_status
-        && h1_check_upgrade(r, con))
+    if (light_btst(r->rqst_htags, HTTP_HEADER_UPGRADE) && 0 == r->http_status && h1_check_upgrade(r, con))
         return 0;
 
     return 1;
 }
 
-
-__attribute_cold__
-static int
-h1_check_expect_100 (request_st * const r, connection * const con)
+__attribute_cold__ static int
+h1_check_expect_100(request_st *const r, connection *const con)
 {
     if (con->is_writable <= 0)
         return 1;
 
-    const buffer * const vb =
-      http_header_request_get(r, HTTP_HEADER_EXPECT,
-                              CONST_STR_LEN("Expect"));
+    const buffer *const vb =
+        http_header_request_get(r, HTTP_HEADER_EXPECT,
+                                CONST_STR_LEN("Expect"));
     if (NULL == vb)
         return 1;
 
@@ -525,11 +534,7 @@ h1_check_expect_100 (request_st * const r, connection * const con)
     int rc = buffer_eq_icase_slen(vb, CONST_STR_LEN("100-continue"));
     http_header_request_unset(r, HTTP_HEADER_EXPECT,
                               CONST_STR_LEN("Expect"));
-    if (!rc
-        || 0 != r->reqbody_queue.bytes_in
-        || !chunkqueue_is_empty(&r->read_queue)
-        || !chunkqueue_is_empty(&r->write_queue)
-        || r->http_version == HTTP_VERSION_1_0)
+    if (!rc || 0 != r->reqbody_queue.bytes_in || !chunkqueue_is_empty(&r->read_queue) || !chunkqueue_is_empty(&r->write_queue) || r->http_version == HTTP_VERSION_1_0)
         return 1;
 
     /* send 100 Continue only if no request body data received yet
@@ -537,28 +542,28 @@ h1_check_expect_100 (request_st * const r, connection * const con)
     return h1_send_100_continue(r, con);
 }
 
-
 static int
-h1_cq_compact (chunkqueue * const cq)
+h1_cq_compact(chunkqueue *const cq)
 {
     /* combine first mem chunk with next non-empty mem chunk
      * (loop if next chunk is empty) */
     chunk *c = cq->first;
-    if (NULL == c) return 0;
+    if (NULL == c)
+        return 0;
     const uint32_t mlen = buffer_clen(c->mem) - (size_t)c->offset;
-    while ((c = c->next)) {
+    while ((c = c->next))
+    {
         const uint32_t blen = buffer_clen(c->mem) - (size_t)c->offset;
-        if (0 == blen) continue;
+        if (0 == blen)
+            continue;
         chunkqueue_compact_mem(cq, mlen + blen);
         return 1;
     }
     return 0;
 }
 
-
-__attribute_pure__
-static int
-h1_chunked_crlf (chunkqueue * const cq)
+__attribute_pure__ static int
+h1_chunked_crlf(chunkqueue *const cq)
 {
     /* caller might check chunkqueue_length(cq) >= 2 before calling here
      * to limit return value to either 1 for good or -1 for error */
@@ -569,110 +574,130 @@ h1_chunked_crlf (chunkqueue * const cq)
 
     /* caller must have called chunkqueue_remove_finished_chunks(cq), so if
      * chunkqueue is not empty, it contains chunk with at least one char */
-    if (chunkqueue_is_empty(cq)) return 0;
+    if (chunkqueue_is_empty(cq))
+        return 0;
 
     c = cq->first;
     b = c->mem;
-    p = b->ptr+c->offset;
-    if (p[0] != '\r') return -1; /* error */
-    if (p[1] == '\n') return 1;
+    p = b->ptr + c->offset;
+    if (p[0] != '\r')
+        return -1; /* error */
+    if (p[1] == '\n')
+        return 1;
     len = buffer_clen(b) - (size_t)c->offset;
-    if (1 != len) return -1; /* error */
+    if (1 != len)
+        return -1; /* error */
 
-    while (NULL != (c = c->next)) {
+    while (NULL != (c = c->next))
+    {
         b = c->mem;
         len = buffer_clen(b) - (size_t)c->offset;
-        if (0 == len) continue;
-        p = b->ptr+c->offset;
+        if (0 == len)
+            continue;
+        p = b->ptr + c->offset;
         return (p[0] == '\n') ? 1 : -1; /* error if not '\n' */
     }
     return 0;
 }
 
-
 static handler_t
-h1_chunked (request_st * const r, chunkqueue * const cq, chunkqueue * const dst_cq)
+h1_chunked(request_st *const r, chunkqueue *const cq, chunkqueue *const dst_cq)
 {
     /* r->conf.max_request_size is in kBytes */
     const off_t max_request_size = (off_t)r->conf.max_request_size << 10;
     off_t te_chunked = r->x.h1.te_chunked;
-    do {
+    do
+    {
         off_t len = chunkqueue_length(cq);
 
-        while (0 == te_chunked) {
+        while (0 == te_chunked)
+        {
             char *p;
             chunk *c = cq->first;
-            if (NULL == c) break;
+            if (NULL == c)
+                break;
             force_assert(c->type == MEM_CHUNK);
-            p = strchr(c->mem->ptr+c->offset, '\n');
-            if (NULL != p) { /* found HTTP chunked header line */
-                off_t hsz = p + 1 - (c->mem->ptr+c->offset);
-                unsigned char *s = (unsigned char *)c->mem->ptr+c->offset;
-                for (unsigned char u;(u=(unsigned char)hex2int(*s))!=0xFF;++s) {
-                    if (te_chunked > (off_t)(1uLL<<(8*sizeof(off_t)-5))-1-2) {
+            p = strchr(c->mem->ptr + c->offset, '\n');
+            if (NULL != p)
+            { /* found HTTP chunked header line */
+                off_t hsz = p + 1 - (c->mem->ptr + c->offset);
+                unsigned char *s = (unsigned char *)c->mem->ptr + c->offset;
+                for (unsigned char u; (u = (unsigned char)hex2int(*s)) != 0xFF; ++s)
+                {
+                    if (te_chunked > (off_t)(1uLL << (8 * sizeof(off_t) - 5)) - 1 - 2)
+                    {
                         log_error(r->conf.errh, __FILE__, __LINE__,
-                          "chunked data size too large -> 400");
+                                  "chunked data size too large -> 400");
                         /* 400 Bad Request */
                         return http_response_reqbody_read_error(r, 400);
                     }
                     te_chunked <<= 4;
                     te_chunked |= u;
                 }
-                if (s == (unsigned char *)c->mem->ptr+c->offset) { /*(no hex)*/
+                if (s == (unsigned char *)c->mem->ptr + c->offset)
+                { /*(no hex)*/
                     log_error(r->conf.errh, __FILE__, __LINE__,
-                      "chunked header invalid chars -> 400");
+                              "chunked header invalid chars -> 400");
                     /* 400 Bad Request */
                     return http_response_reqbody_read_error(r, 400);
                 }
-                while (*s == ' ' || *s == '\t') ++s;
-                if (*s != '\r' && *s != ';') {
+                while (*s == ' ' || *s == '\t')
+                    ++s;
+                if (*s != '\r' && *s != ';')
+                {
                     log_error(r->conf.errh, __FILE__, __LINE__,
-                      "chunked header invalid chars -> 400");
+                              "chunked header invalid chars -> 400");
                     /* 400 Bad Request */
                     return http_response_reqbody_read_error(r, 400);
                 }
 
-                if (hsz >= 1024) {
+                if (hsz >= 1024)
+                {
                     /* prevent theoretical integer overflow
                      * casting to (size_t) and adding 2 (for "\r\n") */
                     log_error(r->conf.errh, __FILE__, __LINE__,
-                      "chunked header line too long -> 400");
+                              "chunked header line too long -> 400");
                     /* 400 Bad Request */
                     return http_response_reqbody_read_error(r, 400);
                 }
 
-                if (0 == te_chunked) {
+                if (0 == te_chunked)
+                {
                     /* do not consume final chunked header until
                      * (optional) trailers received along with
                      * request-ending blank line "\r\n" */
-                    if (p[0] == '\r' && p[1] == '\n') {
+                    if (p[0] == '\r' && p[1] == '\n')
+                    {
                         /*(common case with no trailers; final \r\n received)*/
                         hsz += 2;
                     }
-                    else {
+                    else
+                    {
                         /* trailers or final CRLF crosses into next cq chunk */
                         hsz -= 2;
-                        do {
+                        do
+                        {
                             c = cq->first;
-                            p = strstr(c->mem->ptr+c->offset+hsz, "\r\n\r\n");
+                            p = strstr(c->mem->ptr + c->offset + hsz, "\r\n\r\n");
                         } while (NULL == p && h1_cq_compact(cq));
-                        if (NULL == p) {
+                        if (NULL == p)
+                        {
                             /*(effectively doubles max request field size
                              * potentially received by backend, if in the future
                              * these trailers are added to request headers)*/
-                            if ((off_t)buffer_clen(c->mem) - c->offset
-                                < (off_t)r->conf.max_request_field_size) {
+                            if ((off_t)buffer_clen(c->mem) - c->offset < (off_t)r->conf.max_request_field_size)
+                            {
                                 break;
                             }
-                            else {
+                            else
+                            {
                                 /* ignore excessively long trailers;
                                  * disable keep-alive on connection */
                                 r->keep_alive = 0;
-                                p = c->mem->ptr + buffer_clen(c->mem)
-                                  - 4;
+                                p = c->mem->ptr + buffer_clen(c->mem) - 4;
                             }
                         }
-                        hsz = p + 4 - (c->mem->ptr+c->offset);
+                        hsz = p + 4 - (c->mem->ptr + c->offset);
                         /* trailers currently ignored, but could be processed
                          * here if 0 == (r->conf.stream_request_body &
                          *               & (FDEVENT_STREAM_REQUEST
@@ -689,12 +714,11 @@ h1_chunked (request_st * const r, chunkqueue * const cq, chunkqueue * const dst_
                 chunkqueue_mark_written(cq, (size_t)hsz);
                 len = chunkqueue_length(cq);
 
-                if (0 !=max_request_size
-                    && (max_request_size < te_chunked
-                     || max_request_size - te_chunked < dst_cq->bytes_in)) {
+                if (0 != max_request_size && (max_request_size < te_chunked || max_request_size - te_chunked < dst_cq->bytes_in))
+                {
                     log_error(r->conf.errh, __FILE__, __LINE__,
-                      "request-size too long: %lld -> 413",
-                      (long long)(dst_cq->bytes_in + te_chunked));
+                              "request-size too long: %lld -> 413",
+                              (long long)(dst_cq->bytes_in + te_chunked));
                     /* 413 Payload Too Large */
                     return http_response_reqbody_read_error(r, 413);
                 }
@@ -706,26 +730,33 @@ h1_chunked (request_st * const r, chunkqueue * const cq, chunkqueue * const dst_
 
             /*(likely better ways to handle chunked header crossing chunkqueue
              * chunks, but this situation is not expected to occur frequently)*/
-            if ((off_t)buffer_clen(c->mem) - c->offset >= 1024) {
+            if ((off_t)buffer_clen(c->mem) - c->offset >= 1024)
+            {
                 log_error(r->conf.errh, __FILE__, __LINE__,
-                  "chunked header line too long -> 400");
+                          "chunked header line too long -> 400");
                 /* 400 Bad Request */
                 return http_response_reqbody_read_error(r, 400);
             }
-            else if (!h1_cq_compact(cq)) {
+            else if (!h1_cq_compact(cq))
+            {
                 break;
             }
         }
-        if (0 == te_chunked) break;
+        if (0 == te_chunked)
+            break;
 
-        if (te_chunked > 2) {
-            if (len > te_chunked-2) len = te_chunked-2;
-            if (dst_cq->bytes_in + te_chunked <= 64*1024) {
+        if (te_chunked > 2)
+        {
+            if (len > te_chunked - 2)
+                len = te_chunked - 2;
+            if (dst_cq->bytes_in + te_chunked <= 64 * 1024)
+            {
                 /* avoid buffering request bodies <= 64k on disk */
                 chunkqueue_steal(dst_cq, cq, len);
             }
             else if (0 != chunkqueue_steal_with_tempfiles(dst_cq, cq, len,
-                                                          r->conf.errh)) {
+                                                          r->conf.errh))
+            {
                 /* 500 Internal Server Error */
                 return http_response_reqbody_read_error(r, 500);
             }
@@ -733,16 +764,19 @@ h1_chunked (request_st * const r, chunkqueue * const cq, chunkqueue * const dst_
             len = chunkqueue_length(cq);
         }
 
-        if (len < te_chunked) break;
+        if (len < te_chunked)
+            break;
 
-        if (2 == te_chunked) {
-            if (-1 == h1_chunked_crlf(cq)) {
+        if (2 == te_chunked)
+        {
+            if (-1 == h1_chunked_crlf(cq))
+            {
                 log_error(r->conf.errh, __FILE__, __LINE__,
-                  "chunked data missing end CRLF -> 400");
+                          "chunked data missing end CRLF -> 400");
                 /* 400 Bad Request */
                 return http_response_reqbody_read_error(r, 400);
             }
-            chunkqueue_mark_written(cq, 2);/*consume \r\n at end of chunk data*/
+            chunkqueue_mark_written(cq, 2); /*consume \r\n at end of chunk data*/
             te_chunked -= 2;
         }
 
@@ -752,42 +786,43 @@ h1_chunked (request_st * const r, chunkqueue * const cq, chunkqueue * const dst_
     return HANDLER_GO_ON;
 }
 
-
 static handler_t
-h1_read_body_unknown (request_st * const r, chunkqueue * const cq, chunkqueue * const dst_cq)
+h1_read_body_unknown(request_st *const r, chunkqueue *const cq, chunkqueue *const dst_cq)
 {
     /* r->conf.max_request_size is in kBytes */
     const off_t max_request_size = (off_t)r->conf.max_request_size << 10;
     chunkqueue_append_chunkqueue(dst_cq, cq);
-    if (0 != max_request_size && dst_cq->bytes_in > max_request_size) {
+    if (0 != max_request_size && dst_cq->bytes_in > max_request_size)
+    {
         log_error(r->conf.errh, __FILE__, __LINE__,
-          "request-size too long: %lld -> 413", (long long)dst_cq->bytes_in);
+                  "request-size too long: %lld -> 413", (long long)dst_cq->bytes_in);
         /* 413 Payload Too Large */
         return http_response_reqbody_read_error(r, 413);
     }
     return HANDLER_GO_ON;
 }
 
-
 handler_t
-h1_reqbody_read (request_st * const r)
+h1_reqbody_read(request_st *const r)
 {
-    connection * const con = r->con;
-    chunkqueue * const cq = &r->read_queue;
-    chunkqueue * const dst_cq = &r->reqbody_queue;
+    connection *const con = r->con;
+    chunkqueue *const cq = &r->read_queue;
+    chunkqueue *const dst_cq = &r->reqbody_queue;
 
     int is_closed = 0;
 
-    if (con->is_readable > 0) {
+    if (con->is_readable > 0)
+    {
         con->read_idle_ts = log_monotonic_secs;
         const off_t max_per_read =
-          !(r->conf.stream_request_body /*(if not streaming request body)*/
-            & (FDEVENT_STREAM_REQUEST|FDEVENT_STREAM_REQUEST_BUFMIN))
-            ? MAX_READ_LIMIT
+            !(r->conf.stream_request_body /*(if not streaming request body)*/
+              & (FDEVENT_STREAM_REQUEST | FDEVENT_STREAM_REQUEST_BUFMIN))
+                ? MAX_READ_LIMIT
             : (r->conf.stream_request_body & FDEVENT_STREAM_REQUEST_BUFMIN)
-              ? 16384  /* FDEVENT_STREAM_REQUEST_BUFMIN */
-              : 65536; /* FDEVENT_STREAM_REQUEST */
-        switch(con->network_read(con, cq, max_per_read)) {
+                ? 16384  /* FDEVENT_STREAM_REQUEST_BUFMIN */
+                : 65536; /* FDEVENT_STREAM_REQUEST */
+        switch (con->network_read(con, cq, max_per_read))
+        {
         case -1:
             request_set_state_error(r, CON_STATE_ERROR);
             return HANDLER_ERROR;
@@ -802,85 +837,94 @@ h1_reqbody_read (request_st * const r)
     }
 
     /* Check for Expect: 100-continue in request headers */
-    if (light_btst(r->rqst_htags, HTTP_HEADER_EXPECT)
-        && !h1_check_expect_100(r, con))
+    if (light_btst(r->rqst_htags, HTTP_HEADER_EXPECT) && !h1_check_expect_100(r, con))
         return HANDLER_ERROR;
 
-    if (r->reqbody_length < 0) {
+    if (r->reqbody_length < 0)
+    {
         /*(-1: Transfer-Encoding: chunked, -2: unspecified length)*/
         handler_t rc = (-1 == r->reqbody_length)
-                     ? h1_chunked(r, cq, dst_cq)
-                     : h1_read_body_unknown(r, cq, dst_cq);
-        if (HANDLER_GO_ON != rc) return rc;
+                           ? h1_chunked(r, cq, dst_cq)
+                           : h1_read_body_unknown(r, cq, dst_cq);
+        if (HANDLER_GO_ON != rc)
+            return rc;
         chunkqueue_remove_finished_chunks(cq);
     }
-    else {
+    else
+    {
         off_t len = (off_t)r->reqbody_length - dst_cq->bytes_in;
-        if (r->reqbody_length <= 64*1024) {
+        if (r->reqbody_length <= 64 * 1024)
+        {
             /* don't buffer request bodies <= 64k on disk */
             chunkqueue_steal(dst_cq, cq, len);
         }
-        else if (chunkqueue_length(dst_cq) + len <= 64*1024
-                 && (!dst_cq->first || dst_cq->first->type == MEM_CHUNK)) {
+        else if (chunkqueue_length(dst_cq) + len <= 64 * 1024 && (!dst_cq->first || dst_cq->first->type == MEM_CHUNK))
+        {
             /* avoid tempfiles when streaming request body to fast backend */
             chunkqueue_steal(dst_cq, cq, len);
         }
         else if (0 !=
-                 chunkqueue_steal_with_tempfiles(dst_cq,cq,len,r->conf.errh)) {
+                 chunkqueue_steal_with_tempfiles(dst_cq, cq, len, r->conf.errh))
+        {
             /* writing to temp file failed */ /* Internal Server Error */
             return http_response_reqbody_read_error(r, 500);
         }
         chunkqueue_remove_finished_chunks(cq);
     }
 
-    if (dst_cq->bytes_in == (off_t)r->reqbody_length) {
+    if (dst_cq->bytes_in == (off_t)r->reqbody_length)
+    {
         /* Content is ready */
         r->conf.stream_request_body &= ~FDEVENT_STREAM_REQUEST_POLLIN;
-        if (r->state == CON_STATE_READ_POST) {
+        if (r->state == CON_STATE_READ_POST)
+        {
             request_set_state(r, CON_STATE_HANDLE_REQUEST);
         }
         return HANDLER_GO_ON;
     }
-    else if (is_closed) {
-      #if 0
+    else if (is_closed)
+    {
+#if 0
         return http_response_reqbody_read_error(r, 400); /* Bad Request */
-      #endif
+#endif
         return HANDLER_ERROR;
     }
-    else {
+    else
+    {
         r->conf.stream_request_body |= FDEVENT_STREAM_REQUEST_POLLIN;
         return (r->conf.stream_request_body & FDEVENT_STREAM_REQUEST)
-          ? HANDLER_GO_ON
-          : HANDLER_WAIT_FOR_EVENT;
+                   ? HANDLER_GO_ON
+                   : HANDLER_WAIT_FOR_EVENT;
     }
 }
 
-
 /* keep in sync with connections.c */
 #define HTTP_LINGER_TIMEOUT 5
 
-int
-h1_check_timeout (connection * const con, const unix_time64_t cur_ts)
+int h1_check_timeout(connection *const con, const unix_time64_t cur_ts)
 {
-    request_st * const r = &con->request;
+    request_st *const r = &con->request;
     const int waitevents = fdevent_fdnode_interest(con->fdn);
     int changed = 0;
 
-    if (r->state == CON_STATE_CLOSE) {
+    if (r->state == CON_STATE_CLOSE)
+    {
         if (cur_ts - con->close_timeout_ts > HTTP_LINGER_TIMEOUT)
             changed = 1;
     }
-    else if (waitevents & FDEVENT_IN) {
+    else if (waitevents & FDEVENT_IN)
+    {
         /* keep-alive or else expect CON_STATE_READ_POST || CON_STATE_WRITE */
         int keep_alive = con->request_count != 1 && r->state == CON_STATE_READ;
         int idle_timeout = keep_alive
-          ? con->keep_alive_idle
-          : (int)r->conf.max_read_idle;
-        if (cur_ts - con->read_idle_ts > idle_timeout) {
+                               ? con->keep_alive_idle
+                               : (int)r->conf.max_read_idle;
+        if (cur_ts - con->read_idle_ts > idle_timeout)
+        {
             if (r->conf.log_request_handling)
                 log_error(r->conf.errh, __FILE__, __LINE__,
-                  "connection closed - %s timeout: %d",
-                  keep_alive ? "keep-alive" : "read", con->fd);
+                          "connection closed - %s timeout: %d",
+                          keep_alive ? "keep-alive" : "read", con->fd);
             request_set_state_error(r, CON_STATE_ERROR);
             changed = 1;
         }
@@ -899,26 +943,29 @@ h1_check_timeout (connection * const con, const unix_time64_t cur_ts)
      * interest to client.  (not a priority) */
     /*if (waitevents & FDEVENT_OUT)*/
     if (r->http_version <= HTTP_VERSION_1_1 /*(func reused by h2, h3)*/
-        && r->state == CON_STATE_WRITE && con->write_request_ts != 0) {
-      #if 0
+        && r->state == CON_STATE_WRITE && con->write_request_ts != 0)
+    {
+#if 0
         if (cur_ts - con->write_request_ts > 60) {
             log_error(r->conf.errh, __FILE__, __LINE__,
                       "connection closed - pre-write-request-timeout: %d %d",
                       con->fd, cur_ts - con->write_request_ts);
         }
-      #endif
+#endif
 
-        if (cur_ts - con->write_request_ts > r->conf.max_write_idle) {
+        if (cur_ts - con->write_request_ts > r->conf.max_write_idle)
+        {
             /* time - out */
-            if (r->conf.log_timeouts) {
+            if (r->conf.log_timeouts)
+            {
                 log_error(r->conf.errh, __FILE__, __LINE__,
-                  "NOTE: a request from %s for %.*s timed out after writing "
-                  "%lld bytes. We waited %d seconds. If this is a problem, "
-                  "increase server.max-write-idle",
-                  r->dst_addr_buf->ptr,
-                  BUFFER_INTLEN_PTR(&r->target),
-                  (long long)con->write_queue->bytes_out,
-                  (int)r->conf.max_write_idle);
+                          "NOTE: a request from %s for %.*s timed out after writing "
+                          "%lld bytes. We waited %d seconds. If this is a problem, "
+                          "increase server.max-write-idle",
+                          r->dst_addr_buf->ptr,
+                          BUFFER_INTLEN_PTR(&r->target),
+                          (long long)con->write_queue->bytes_out,
+                          (int)r->conf.max_write_idle);
             }
             request_set_state_error(r, CON_STATE_ERROR);
             changed = 1;
diff --git a/src/server.c b/src/server.c
index 44385db1..76f422e4 100644
--- a/src/server.c
+++ b/src/server.c
@@ -6,7 +6,7 @@
 #include "log.h"
 #include "rand.h"
 #include "chunk.h"
-#include "http_range.h"     /* http_range_config_allow_http10() */
+#include "http_range.h" /* http_range_config_allow_http10() */
 #include "fdevent.h"
 #include "fdlog.h"
 #include "connections.h"
@@ -14,20 +14,20 @@
 #include "stat_cache.h"
 #include "plugin.h"
 #include "plugins.h"
-#include "plugin_config.h"  /* config_plugin_value_tobool() */
-#include "network_write.h"  /* network_write_show_handlers() */
-#include "reqpool.h"        /* request_pool_init() request_pool_free() */
-#include "response.h"       /* http_dispatch[] strftime_cache_reset() */
+#include "plugin_config.h" /* config_plugin_value_tobool() */
+#include "network_write.h" /* network_write_show_handlers() */
+#include "reqpool.h"	   /* request_pool_init() request_pool_free() */
+#include "response.h"	   /* http_dispatch[] strftime_cache_reset() */
 
 #ifdef HAVE_VERSIONSTAMP_H
-# include "versionstamp.h"
+#include "versionstamp.h"
 #else
-# define REPO_VERSION ""
+#define REPO_VERSION ""
 #endif
 
 #define PACKAGE_DESC PACKAGE_NAME "/" PACKAGE_VERSION REPO_VERSION
 static const buffer default_server_tag =
-  { PACKAGE_DESC "\0server", sizeof(PACKAGE_DESC), 0 };
+	{PACKAGE_DESC "\0server", sizeof(PACKAGE_DESC), 0};
 
 #include <sys/types.h>
 #include "sys-setjmp.h"
@@ -42,102 +42,112 @@ static const buffer default_server_tag =
 #include <signal.h>
 #include <locale.h>
 #ifdef _WIN32
-#include <mbctype.h>    /* _setmbcp() */
+#include <mbctype.h> /* _setmbcp() */
 #endif
 
 #include <stdio.h>
 
 #ifdef HAVE_GETOPT_H
-# include <getopt.h>
+#include <getopt.h>
 #else
 /* basic (very limited) getopt() implementation */
 extern char *optarg;
 extern int optind, opterr, optopt;
 char *optarg = NULL;
 int optind = 1, opterr = 1, optopt = 0;
-int getopt (int argc, char * const argv[], const char *optstring);
-int getopt (int argc, char * const argv[], const char *optstring)
+int getopt(int argc, char *const argv[], const char *optstring);
+int getopt(int argc, char *const argv[], const char *optstring)
 {
-    static char *nextchar;
-    optarg = NULL;
-    if (optind >= argc || argc < 1)
-        return -1;
-    if (optind <= 1)
-        nextchar = argv[(optind = 1)];
-    else if (nextchar == NULL)
-        nextchar = argv[optind];
-
-    if (nextchar == argv[optind]) {
-        if (*nextchar++ != '-'
-            || nextchar[0] == '\0' /* "-" */
-            || (nextchar[0] == '-' && nextchar[1] == '\0')) { /* "--" */
-            return -1;
-        }
-        ++optind;
-    }
-
-    const char *o = optstring;
-    if (*o == '+' || *o == '-') ++o; /*(ignore; behave as if '+' is set)*/
-    if (*o == ':') ++o;              /*(ignore; behave as if ':' is set)*/
-    for (; *o; ++o) {
-        if (*o == *nextchar)
-            break;
-        if (o[1] == ':') ++o;
-        if (o[1] == ':') ++o;
-    }
-    if (!*o) {
-        /* if (opterr) fprintf(stderr, "..."); */
-        optopt = *nextchar;
-        return '?';
-    }
-
-    if (!*++nextchar)
-        nextchar = NULL;
-
-    if (o[1] == ':') {
-        if (nextchar) {
-            optarg = nextchar;
-            nextchar = NULL;
-        }
-        else if (optind < argc)
-            optarg = argv[optind++];
-        else if (o[2] != ':') {
-            /* if (opterr) fprintf(stderr, "..."); */
-              /*(fprintf if ':' not at beginning of optstring)*/
-            optopt = *o;
-            return ':';
-        }
-    }
-
-    return *o;
+	static char *nextchar;
+	optarg = NULL;
+	if (optind >= argc || argc < 1)
+		return -1;
+	if (optind <= 1)
+		nextchar = argv[(optind = 1)];
+	else if (nextchar == NULL)
+		nextchar = argv[optind];
+
+	if (nextchar == argv[optind])
+	{
+		if (*nextchar++ != '-' || nextchar[0] == '\0' /* "-" */
+			|| (nextchar[0] == '-' && nextchar[1] == '\0'))
+		{ /* "--" */
+			return -1;
+		}
+		++optind;
+	}
+
+	const char *o = optstring;
+	if (*o == '+' || *o == '-')
+		++o; /*(ignore; behave as if '+' is set)*/
+	if (*o == ':')
+		++o; /*(ignore; behave as if ':' is set)*/
+	for (; *o; ++o)
+	{
+		if (*o == *nextchar)
+			break;
+		if (o[1] == ':')
+			++o;
+		if (o[1] == ':')
+			++o;
+	}
+	if (!*o)
+	{
+		/* if (opterr) fprintf(stderr, "..."); */
+		optopt = *nextchar;
+		return '?';
+	}
+
+	if (!*++nextchar)
+		nextchar = NULL;
+
+	if (o[1] == ':')
+	{
+		if (nextchar)
+		{
+			optarg = nextchar;
+			nextchar = NULL;
+		}
+		else if (optind < argc)
+			optarg = argv[optind++];
+		else if (o[2] != ':')
+		{
+			/* if (opterr) fprintf(stderr, "..."); */
+			/*(fprintf if ':' not at beginning of optstring)*/
+			optopt = *o;
+			return ':';
+		}
+	}
+
+	return *o;
 }
 #endif
 
 #ifdef HAVE_VALGRIND_VALGRIND_H
-# include <valgrind/valgrind.h>
+#include <valgrind/valgrind.h>
 #endif
 
 #ifdef HAVE_PWD_H
-# include <grp.h>
-# include <pwd.h>
+#include <grp.h>
+#include <pwd.h>
 #endif
 
 #ifdef HAVE_SYS_LOADAVG_H
-# include <sys/loadavg.h>
+#include <sys/loadavg.h>
 #endif
 
 #ifdef HAVE_SYS_RESOURCE_H
-# include <sys/resource.h>
+#include <sys/resource.h>
 #endif
 
 #ifdef HAVE_SYS_PRCTL_H
-# include <sys/prctl.h>
+#include <sys/prctl.h>
 #endif
 #ifdef HAVE_SYS_PROCCTL_H
-# include <sys/procctl.h>
+#include <sys/procctl.h>
 #endif
 #ifdef HAVE_PRIV_H
-# include <priv.h>
+#include <priv.h>
 #endif
 
 #ifdef HAVE_MALLOC_H
@@ -148,17 +158,13 @@ int getopt (int argc, char * const argv[], const char *optstring)
 #endif
 #include <malloc.h>
 #if defined(HAVE_MALLOC_TRIM)
-static int(*malloc_trim_fn)(size_t);
+static int (*malloc_trim_fn)(size_t);
 static size_t malloc_top_pad;
 #endif
 #endif
 
 #include "sys-crypto.h"
-#if defined(USE_OPENSSL_CRYPTO) \
- || defined(USE_MBEDTLS_CRYPTO) \
- || defined(USE_NSS_CRYPTO) \
- || defined(USE_GNUTLS_CRYPTO) \
- || defined(USE_WOLFTLS_CRYPTO)
+#if defined(USE_OPENSSL_CRYPTO) || defined(USE_MBEDTLS_CRYPTO) || defined(USE_NSS_CRYPTO) || defined(USE_GNUTLS_CRYPTO) || defined(USE_WOLFTLS_CRYPTO)
 #define TEXT_SSL " (ssl)"
 #else
 #define TEXT_SSL
@@ -173,14 +179,13 @@ static size_t malloc_top_pad;
 /* (Note: assume overwrite == 1 in this setenv() replacement) */
 /*#define setenv(name,value,overwrite)  SetEnvironmentVariable((name),(value))*/
 /*#define unsetenv(name)                SetEnvironmentVariable((name),NULL)*/
-#define setenv(name,value,overwrite)  _putenv_s((name), strdup(value))
-#define unsetenv(name)                _putenv_s((name), "")
+#define setenv(name, value, overwrite) _putenv_s((name), strdup(value))
+#define unsetenv(name) _putenv_s((name), "")
 #endif
 
 #include "h1.h"
 static const struct http_dispatch h1_1_dispatch_table = {
-  .send_1xx          = h1_send_1xx
-};
+	.send_1xx = h1_send_1xx};
 
 static int oneshot_fd = 0;
 static int oneshot_fdout = -1;
@@ -197,8 +202,7 @@ static volatile sig_atomic_t handle_sig_alarm = 1;
 static volatile sig_atomic_t handle_sig_hup = 0;
 static int idle_limit = 0;
 
-__attribute_cold__
-int server_main (int argc, char ** argv);
+__attribute_cold__ int server_main(int argc, char **argv);
 
 #ifdef _WIN32
 #ifndef SIGBREAK
@@ -215,38 +219,45 @@ int server_main (int argc, char ** argv);
 static volatile siginfo_t last_sigterm_info;
 static volatile siginfo_t last_sighup_info;
 
-static void sigaction_handler(int sig, siginfo_t *si, void *context) {
+static void sigaction_handler(int sig, siginfo_t *si, void *context)
+{
 	static const siginfo_t empty_siginfo;
 	UNUSED(context);
 
-	if (!si) *(const siginfo_t **)&si = &empty_siginfo;
+	if (!si)
+		*(const siginfo_t **)&si = &empty_siginfo;
 
-	switch (sig) {
+	switch (sig)
+	{
 	case SIGTERM:
 		srv_shutdown = 1;
 		last_sigterm_info = *si;
 		break;
 	case SIGUSR1:
-		if (!graceful_shutdown) {
+		if (!graceful_shutdown)
+		{
 			graceful_restart = 1;
 			graceful_shutdown = 1;
 			last_sigterm_info = *si;
 		}
 		break;
 	case SIGINT:
-		if (graceful_shutdown) {
+		if (graceful_shutdown)
+		{
 			if (2 == graceful_restart)
 				graceful_restart = 1;
 			else
 				srv_shutdown = 1;
-		} else {
+		}
+		else
+		{
 			graceful_shutdown = 1;
 		}
 		last_sigterm_info = *si;
 
 		break;
-	case SIGALRM: 
-		handle_sig_alarm = 1; 
+	case SIGALRM:
+		handle_sig_alarm = 1;
 		break;
 	case SIGHUP:
 		handle_sig_hup = 1;
@@ -258,30 +269,44 @@ static void sigaction_handler(int sig, siginfo_t *si, void *context) {
 	}
 }
 #elif defined(HAVE_SIGNAL) || defined(HAVE_SIGACTION)
-static void signal_handler(int sig) {
-	switch (sig) {
-	case SIGTERM: srv_shutdown = 1; break;
+static void signal_handler(int sig)
+{
+	switch (sig)
+	{
+	case SIGTERM:
+		srv_shutdown = 1;
+		break;
 	case SIGUSR1:
-		if (!graceful_shutdown) {
+		if (!graceful_shutdown)
+		{
 			graceful_restart = 1;
 			graceful_shutdown = 1;
 		}
 		break;
 	case SIGINT:
-		if (graceful_shutdown) {
+		if (graceful_shutdown)
+		{
 			if (2 == graceful_restart)
 				graceful_restart = 1;
 			else
 				srv_shutdown = 1;
-		} else {
+		}
+		else
+		{
 			graceful_shutdown = 1;
 		}
 		break;
-  #ifndef _WIN32
-	case SIGALRM: handle_sig_alarm = 1; break;
-	case SIGHUP:  handle_sig_hup = 1; break;
-	case SIGCHLD: handle_sig_child = 1; break;
-  #endif
+#ifndef _WIN32
+	case SIGALRM:
+		handle_sig_alarm = 1;
+		break;
+	case SIGHUP:
+		handle_sig_hup = 1;
+		break;
+	case SIGCHLD:
+		handle_sig_child = 1;
+		break;
+#endif
 	}
 }
 #endif
@@ -290,105 +315,108 @@ static void signal_handler(int sig) {
 #ifdef _WIN32
 static BOOL WINAPI ConsoleCtrlHandler(DWORD dwType)
 {
-    /* Note: Windows handles "signals" inconsistently, varying depending on
-     * whether or not the program is attached to a non-hidden window.
-     * CTRL_CLOSE_EVENT sent by taskkill can be received if attached to a
-     * non-hidden window, but taskkill /f must be used (and CTRL_CLOSE_EVENT
-     * is not received here) if process is not attached to a window, or if
-     * the window is hidden. (WTH MS?!)  This *does not* catch CTRL_CLOSE_EVENT:
-     *   start -FilePath .\lighttpd.exe -ArgumentList "-D -f lighttpd.conf"
-     *     -WindowStyle Hidden   # (or None)
-     * but any other -WindowStyle can catch CTRL_CLOSE_EVENT.
-     * CTRL_C_EVENT can only be sent to 0 (self process group) or self pid
-     * and is ignored by default (sending signal does not indicate failure)
-     * in numerous other cases.  Some people have resorted to standalone helper
-     * programs to attempt AttachConsole() to a target pid before sending
-     * CTRL_C_EVENT via GenerateConsoleCtrlEvent().  Another alternative is
-     * running lighttpd as a Windows service, which uses a different mechanism,
-     * also more limited than unix signals.  Other alternatives include
-     * NSSM (Non-Sucking Service Manager) or cygwin's cygrunsrv program */
-    switch(dwType) {
-      case CTRL_C_EVENT:
-        signal_handler(SIGINT);
-        break;
-      case CTRL_BREAK_EVENT:
-        /* Ctrl-BREAK (repurposed and treated as SIGUSR1)*/
-        signal_handler(SIGUSR1);
-        break;
-      case CTRL_CLOSE_EVENT:/* sent by taskkill */
-      case CTRL_LOGOFF_EVENT:
-      case CTRL_SHUTDOWN_EVENT:
-        /* non-cancellable event; program terminates soon after return */
-        signal_handler(SIGTERM);/* trigger server shutdown in main thread */
-        Sleep(2000);            /* sleep 2 secs to give threads chance to exit*/
-        return FALSE;
-    }
-    return TRUE;
+	/* Note: Windows handles "signals" inconsistently, varying depending on
+	 * whether or not the program is attached to a non-hidden window.
+	 * CTRL_CLOSE_EVENT sent by taskkill can be received if attached to a
+	 * non-hidden window, but taskkill /f must be used (and CTRL_CLOSE_EVENT
+	 * is not received here) if process is not attached to a window, or if
+	 * the window is hidden. (WTH MS?!)  This *does not* catch CTRL_CLOSE_EVENT:
+	 *   start -FilePath .\lighttpd.exe -ArgumentList "-D -f lighttpd.conf"
+	 *     -WindowStyle Hidden   # (or None)
+	 * but any other -WindowStyle can catch CTRL_CLOSE_EVENT.
+	 * CTRL_C_EVENT can only be sent to 0 (self process group) or self pid
+	 * and is ignored by default (sending signal does not indicate failure)
+	 * in numerous other cases.  Some people have resorted to standalone helper
+	 * programs to attempt AttachConsole() to a target pid before sending
+	 * CTRL_C_EVENT via GenerateConsoleCtrlEvent().  Another alternative is
+	 * running lighttpd as a Windows service, which uses a different mechanism,
+	 * also more limited than unix signals.  Other alternatives include
+	 * NSSM (Non-Sucking Service Manager) or cygwin's cygrunsrv program */
+	switch (dwType)
+	{
+	case CTRL_C_EVENT:
+		signal_handler(SIGINT);
+		break;
+	case CTRL_BREAK_EVENT:
+		/* Ctrl-BREAK (repurposed and treated as SIGUSR1)*/
+		signal_handler(SIGUSR1);
+		break;
+	case CTRL_CLOSE_EVENT: /* sent by taskkill */
+	case CTRL_LOGOFF_EVENT:
+	case CTRL_SHUTDOWN_EVENT:
+		/* non-cancellable event; program terminates soon after return */
+		signal_handler(SIGTERM); /* trigger server shutdown in main thread */
+		Sleep(2000);			 /* sleep 2 secs to give threads chance to exit*/
+		return FALSE;
+	}
+	return TRUE;
 }
 #endif
 #endif
 
-static void server_main_setup_signals (void) {
-  #ifdef HAVE_SIGACTION
-    struct sigaction act;
-    memset(&act, 0, sizeof(act));
-    sigemptyset(&act.sa_mask);
-
-    act.sa_handler = SIG_IGN;
-    sigaction(SIGPIPE, &act, NULL);
-
-   #ifndef _MSC_VER
-    act.sa_flags = SA_NODEFER;
-    act.sa_handler = sys_setjmp_sigbus;
-    sigaction(SIGBUS, &act, NULL);
-    act.sa_flags = 0;
-   #endif
-
-   #if defined(SA_SIGINFO)
-    last_sighup_info.si_uid = 0,
-    last_sighup_info.si_pid = 0;
-    last_sigterm_info.si_uid = 0,
-    last_sigterm_info.si_pid = 0;
-    act.sa_sigaction = sigaction_handler;
-    act.sa_flags = SA_SIGINFO;
-   #else
-    act.sa_handler = signal_handler;
-    act.sa_flags = 0;
-   #endif
-    sigaction(SIGINT,  &act, NULL);
-    sigaction(SIGTERM, &act, NULL);
-    sigaction(SIGHUP,  &act, NULL);
-    sigaction(SIGALRM, &act, NULL);
-    sigaction(SIGUSR1, &act, NULL);
-
-    /* it should be safe to restart syscalls after SIGCHLD */
-    act.sa_flags |= SA_RESTART | SA_NOCLDSTOP;
-    sigaction(SIGCHLD, &act, NULL);
-  #elif defined(HAVE_SIGNAL)
-   #ifndef _WIN32
-    /* ignore the SIGPIPE from sendfile() */
-    signal(SIGPIPE, SIG_IGN);
-   #endif
-    signal(SIGINT,  signal_handler);
-    signal(SIGTERM, signal_handler);
-   #ifndef _WIN32
-    signal(SIGHUP,  signal_handler);
-    signal(SIGALRM, signal_handler);
-    signal(SIGUSR1, signal_handler);
-    signal(SIGCHLD, signal_handler);
-   #else
-    /* Ctrl-BREAK (repurposed and treated as SIGUSR1)*/
-    signal(SIGUSR1, signal_handler);
-    SetConsoleCtrlHandler((PHANDLER_ROUTINE)ConsoleCtrlHandler,TRUE);
-   #endif
-   #ifndef _MSC_VER
-    signal(SIGBUS,  sys_setjmp_sigbus);
-   #endif
-  #endif
+static void server_main_setup_signals(void)
+{
+#ifdef HAVE_SIGACTION
+	struct sigaction act;
+	memset(&act, 0, sizeof(act));
+	sigemptyset(&act.sa_mask);
+
+	act.sa_handler = SIG_IGN;
+	sigaction(SIGPIPE, &act, NULL);
+
+#ifndef _MSC_VER
+	act.sa_flags = SA_NODEFER;
+	act.sa_handler = sys_setjmp_sigbus;
+	sigaction(SIGBUS, &act, NULL);
+	act.sa_flags = 0;
+#endif
+
+#if defined(SA_SIGINFO)
+	last_sighup_info.si_uid = 0,
+	last_sighup_info.si_pid = 0;
+	last_sigterm_info.si_uid = 0,
+	last_sigterm_info.si_pid = 0;
+	act.sa_sigaction = sigaction_handler;
+	act.sa_flags = SA_SIGINFO;
+#else
+	act.sa_handler = signal_handler;
+	act.sa_flags = 0;
+#endif
+	sigaction(SIGINT, &act, NULL);
+	sigaction(SIGTERM, &act, NULL);
+	sigaction(SIGHUP, &act, NULL);
+	sigaction(SIGALRM, &act, NULL);
+	sigaction(SIGUSR1, &act, NULL);
+
+	/* it should be safe to restart syscalls after SIGCHLD */
+	act.sa_flags |= SA_RESTART | SA_NOCLDSTOP;
+	sigaction(SIGCHLD, &act, NULL);
+#elif defined(HAVE_SIGNAL)
+#ifndef _WIN32
+	/* ignore the SIGPIPE from sendfile() */
+	signal(SIGPIPE, SIG_IGN);
+#endif
+	signal(SIGINT, signal_handler);
+	signal(SIGTERM, signal_handler);
+#ifndef _WIN32
+	signal(SIGHUP, signal_handler);
+	signal(SIGALRM, signal_handler);
+	signal(SIGUSR1, signal_handler);
+	signal(SIGCHLD, signal_handler);
+#else
+	/* Ctrl-BREAK (repurposed and treated as SIGUSR1)*/
+	signal(SIGUSR1, signal_handler);
+	SetConsoleCtrlHandler((PHANDLER_ROUTINE)ConsoleCtrlHandler, TRUE);
+#endif
+#ifndef _MSC_VER
+	signal(SIGBUS, sys_setjmp_sigbus);
+#endif
+#endif
 }
 
 #ifdef HAVE_FORK
-static int daemonize(void) {
+static int daemonize(void)
+{
 	int pipefd[2];
 	pid_t pid;
 #ifdef SIGTTOU
@@ -401,22 +429,27 @@ static int daemonize(void) {
 	signal(SIGTSTP, SIG_IGN);
 #endif
 
-	if (fdevent_pipe_cloexec(pipefd, 64) < 0) exit(-1);
+	if (fdevent_pipe_cloexec(pipefd, 64) < 0)
+		exit(-1);
 
-	if (0 > (pid = fork())) exit(-1);
+	if (0 > (pid = fork()))
+		exit(-1);
 
-	if (0 < pid) {
+	if (0 < pid)
+	{
 		char buf;
 		ssize_t bytes;
 
 		close(pipefd[1]);
 		/* parent waits for grandchild to be ready */
-		do {
+		do
+		{
 			bytes = read(pipefd[0], &buf, sizeof(buf));
 		} while (bytes < 0 && EINTR == errno);
 		close(pipefd[0]);
 
-		if (bytes <= 0) {
+		if (bytes <= 0)
+		{
 			/* closed fd (without writing) == failure in grandchild */
 			fputs("daemonized server failed to start; check error log for details\n", stderr);
 			exit(-1);
@@ -427,13 +460,16 @@ static int daemonize(void) {
 
 	close(pipefd[0]);
 
-	if (-1 == setsid()) exit(0);
+	if (-1 == setsid())
+		exit(0);
 
 	signal(SIGHUP, SIG_IGN);
 
-	if (0 != fork()) exit(0);
+	if (0 != fork())
+		exit(0);
 
-	if (0 != chdir("/")) exit(0);
+	if (0 != chdir("/"))
+		exit(0);
 
 	return pipefd[1];
 }
@@ -442,47 +478,50 @@ static int daemonize(void) {
 static int clockid_mono_coarse = 0;
 
 static unix_time64_t
-server_monotonic_secs (void)
+server_monotonic_secs(void)
 {
-  #ifdef _MSC_VER
-    return (unix_time64_t)(GetTickCount64() / 1000);
-  #else
-    unix_timespec64_t ts;
-    return (0 == log_clock_gettime(clockid_mono_coarse, &ts))
-      ? ts.tv_sec
-      : log_monotonic_secs;
-  #endif
+#ifdef _MSC_VER
+	return (unix_time64_t)(GetTickCount64() / 1000);
+#else
+	unix_timespec64_t ts;
+	return (0 == log_clock_gettime(clockid_mono_coarse, &ts))
+			   ? ts.tv_sec
+			   : log_monotonic_secs;
+#endif
 }
 
 static unix_time64_t
-server_epoch_secs (server * const srv, unix_time64_t mono_ts_delta)
+server_epoch_secs(server *const srv, unix_time64_t mono_ts_delta)
 {
-    const unix_time64_t cur_ts = log_epoch_secs;
-    const unix_time64_t new_ts = TIME64_CAST(time(NULL));
-    const unix_time64_t new_ts_adj = new_ts - mono_ts_delta;
-    /* attempt to detect large clock jump */
-    if (new_ts_adj < cur_ts || new_ts_adj - cur_ts > 300) { /*(5 mins)*/
-        log_error(srv->errh, __FILE__, __LINE__,
-          "warning: clock jumped %lld secs",
-          (long long)((int64_t)new_ts_adj - (int64_t)cur_ts));
-        int delta =                             /*(30 mins default)*/
-          config_feature_int(srv, "server.clock-jump-restart", 1800);
-        if (delta && (new_ts_adj > cur_ts
-                      ? new_ts_adj-cur_ts
-                      : cur_ts-new_ts_adj) > delta) {
-            log_error(srv->errh, __FILE__, __LINE__,
-              "attempting graceful restart in < ~5 seconds, else hard restart");
-            srv->graceful_expire_ts = log_monotonic_secs + 5;
-            raise(SIGUSR1);
-        }
-    }
-    return new_ts;
+	const unix_time64_t cur_ts = log_epoch_secs;
+	const unix_time64_t new_ts = TIME64_CAST(time(NULL));
+	const unix_time64_t new_ts_adj = new_ts - mono_ts_delta;
+	/* attempt to detect large clock jump */
+	if (new_ts_adj < cur_ts || new_ts_adj - cur_ts > 300)
+	{ /*(5 mins)*/
+		log_error(srv->errh, __FILE__, __LINE__,
+				  "warning: clock jumped %lld secs",
+				  (long long)((int64_t)new_ts_adj - (int64_t)cur_ts));
+		int delta = /*(30 mins default)*/
+			config_feature_int(srv, "server.clock-jump-restart", 1800);
+		if (delta && (new_ts_adj > cur_ts
+						  ? new_ts_adj - cur_ts
+						  : cur_ts - new_ts_adj) > delta)
+		{
+			log_error(srv->errh, __FILE__, __LINE__,
+					  "attempting graceful restart in < ~5 seconds, else hard restart");
+			srv->graceful_expire_ts = log_monotonic_secs + 5;
+			raise(SIGUSR1);
+		}
+	}
+	return new_ts;
 }
 
 __attribute_cold__
-__attribute_noinline__
-__attribute_returns_nonnull__
-static server *server_init(void) {
+	__attribute_noinline__
+		__attribute_returns_nonnull__ static server *
+		server_init(void)
+{
 	server *srv = ck_calloc(1, sizeof(*srv));
 
 	srv->tmp_buf = buffer_init();
@@ -492,26 +531,26 @@ static server *server_init(void) {
 	li_rand_reseed();
 
 	srv->startup_ts = log_epoch_secs = TIME64_CAST(time(NULL));
-  #ifdef HAVE_CLOCK_GETTIME
+#ifdef HAVE_CLOCK_GETTIME
 	unix_timespec64_t ts;
 	UNUSED(&ts);
-   #ifdef CLOCK_MONOTONIC_COARSE
+#ifdef CLOCK_MONOTONIC_COARSE
 	if (0 == log_clock_gettime(CLOCK_MONOTONIC_COARSE, &ts))
 		clockid_mono_coarse = CLOCK_MONOTONIC_COARSE;
 	else
-   #endif
-   #ifdef CLOCK_MONOTONIC_RAW_APPROX
-	if (0 == log_clock_gettime(CLOCK_MONOTONIC_RAW_APPROX, &ts))
+#endif
+#ifdef CLOCK_MONOTONIC_RAW_APPROX
+		if (0 == log_clock_gettime(CLOCK_MONOTONIC_RAW_APPROX, &ts))
 		clockid_mono_coarse = CLOCK_MONOTONIC_RAW_APPROX;
 	else
-   #endif
-   #ifdef CLOCK_MONOTONIC_RAW
-	if (0 == log_clock_gettime(CLOCK_MONOTONIC_RAW, &ts))
+#endif
+#ifdef CLOCK_MONOTONIC_RAW
+		if (0 == log_clock_gettime(CLOCK_MONOTONIC_RAW, &ts))
 		clockid_mono_coarse = CLOCK_MONOTONIC_RAW;
 	else
-   #endif
+#endif
 		clockid_mono_coarse = CLOCK_MONOTONIC;
-  #endif
+#endif
 	log_monotonic_secs = server_monotonic_secs();
 
 	srv->errh = log_set_global_errh(NULL, 0);
@@ -527,17 +566,20 @@ static server *server_init(void) {
 	srv->stdin_fd = -1;
 	srv->default_server_tag = &default_server_tag;
 
-	log_con_jqueue = (connection *)(uintptr_t)&log_con_jqueue;/*(sentinel)*/
+	log_con_jqueue = (connection *)(uintptr_t)&log_con_jqueue; /*(sentinel)*/
 	memset(http_dispatch, 0, sizeof(http_dispatch));
 
 	return srv;
 }
 
 __attribute_cold__
-__attribute_noinline__
-static void server_free(server *srv) {
-	if (oneshot_fd > 0) {
-		if (oneshot_fdn) {
+	__attribute_noinline__ static void
+	server_free(server *srv)
+{
+	if (oneshot_fd > 0)
+	{
+		if (oneshot_fdn)
+		{
 			fdevent_fdnode_event_del(srv->ev, oneshot_fdn);
 			fdevent_unregister(srv->ev, oneshot_fdn);
 			oneshot_fdn = NULL;
@@ -547,10 +589,12 @@ static void server_free(server *srv) {
 		else
 			fdio_close_socket(oneshot_fd);
 	}
-	if (oneshot_fdout >= 0) {
+	if (oneshot_fdout >= 0)
+	{
 		fdio_close_pipe(oneshot_fdout);
 	}
-	if (srv->stdin_fd >= 0) {
+	if (srv->stdin_fd >= 0)
+	{
 		fdio_close_socket(srv->stdin_fd);
 	}
 
@@ -571,827 +615,924 @@ static void server_free(server *srv) {
 }
 
 __attribute_cold__
-__attribute_noinline__
-static void remove_pid_file(server *srv) {
-	if (pid_fd <= -2) return;
-	if (srv->srvconf.pid_file && 0 <= pid_fd) {
-		if (0 != ftruncate(pid_fd, 0)) {
+	__attribute_noinline__ static void
+	remove_pid_file(server *srv)
+{
+	if (pid_fd <= -2)
+		return;
+	if (srv->srvconf.pid_file && 0 <= pid_fd)
+	{
+		if (0 != ftruncate(pid_fd, 0))
+		{
 			log_perror(srv->errh, __FILE__, __LINE__,
-			  "ftruncate failed for: %s", srv->srvconf.pid_file->ptr);
+					   "ftruncate failed for: %s", srv->srvconf.pid_file->ptr);
 		}
 	}
-	if (0 <= pid_fd) {
+	if (0 <= pid_fd)
+	{
 		close(pid_fd);
 		pid_fd = -1;
 	}
-	if (srv->srvconf.pid_file && !srv->srvconf.changeroot) {
-		if (0 != unlink(srv->srvconf.pid_file->ptr)) {
-			if (errno != EACCES && errno != EPERM) {
+	if (srv->srvconf.pid_file && !srv->srvconf.changeroot)
+	{
+		if (0 != unlink(srv->srvconf.pid_file->ptr))
+		{
+			if (errno != EACCES && errno != EPERM)
+			{
 				log_perror(srv->errh, __FILE__, __LINE__,
-				  "unlink failed for: %s", srv->srvconf.pid_file->ptr);
+						   "unlink failed for: %s", srv->srvconf.pid_file->ptr);
 			}
 		}
 	}
 }
 
-
-__attribute_cold__
-static server_socket * server_oneshot_getsock(server *srv, sock_addr *cnt_addr) {
+__attribute_cold__ static server_socket *server_oneshot_getsock(server *srv, sock_addr *cnt_addr)
+{
 	server_socket *srv_socket, *srv_socket_wild = NULL;
-	for (uint32_t i = 0; i < srv->srv_sockets.used; ++i) {
+	for (uint32_t i = 0; i < srv->srv_sockets.used; ++i)
+	{
 		srv_socket = srv->srv_sockets.ptr[i];
-		if (!sock_addr_is_port_eq(&srv_socket->addr,cnt_addr)) continue;
-		if (sock_addr_is_addr_eq(&srv_socket->addr,cnt_addr)) return srv_socket;
-
-		if (NULL != srv_socket_wild) continue;
-		if (sock_addr_is_addr_wildcard(&srv_socket->addr)) {
+		if (!sock_addr_is_port_eq(&srv_socket->addr, cnt_addr))
+			continue;
+		if (sock_addr_is_addr_eq(&srv_socket->addr, cnt_addr))
+			return srv_socket;
+
+		if (NULL != srv_socket_wild)
+			continue;
+		if (sock_addr_is_addr_wildcard(&srv_socket->addr))
+		{
 			srv_socket_wild = srv_socket;
 		}
 	}
 
-	if (NULL != srv_socket_wild) {
+	if (NULL != srv_socket_wild)
+	{
 		return srv_socket_wild;
-	} else if (srv->srv_sockets.used) {
+	}
+	else if (srv->srv_sockets.used)
+	{
 		return srv->srv_sockets.ptr[0];
-	} else {
+	}
+	else
+	{
 		log_error(srv->errh, __FILE__, __LINE__, "no sockets configured");
 		return NULL;
 	}
 }
 
+static int server_oneshot_read_cq(connection *con, chunkqueue *cq, off_t max_bytes)
+{
+	/* temporary set con->fd to oneshot_fd (fd input) rather than outshot_fdout
+	 * (lighttpd generally assumes operation on sockets, so this is a kludge) */
+	int fd = con->fd;
+	con->fd = oneshot_fdn->fd;
+	int rc = oneshot_read_cq(con, cq, max_bytes);
+	con->fd = fd;
+
+	/* note: optimistic reads (elsewhere) may or may not be enough to re-enable
+	 * read interest after FDEVENT_IN interest was paused for other reasons */
+
+	const int events = fdevent_fdnode_interest(oneshot_fdn);
+	int n = con->is_readable > 0 ? 0 : FDEVENT_IN;
+	if (events & FDEVENT_RDHUP)
+		n |= FDEVENT_RDHUP;
+	fdevent_fdnode_event_set(con->srv->ev, oneshot_fdn, n);
+	return rc;
+}
+
+static handler_t server_oneshot_handle_fdevent(void *context, int revents)
+{
+	connection *con = context;
+
+	/* note: not sync'd with con->fdn or connection_set_fdevent_interest() */
+	int rdhup = 0;
+	int n = fdevent_fdnode_interest(oneshot_fdn);
+	if (revents & FDEVENT_IN)
+		n &= ~FDEVENT_IN;
+	request_st *const r = &con->request;
+	if (r->state != CON_STATE_ERROR && (revents & (FDEVENT_HUP | FDEVENT_RDHUP)))
+	{
+		revents &= ~(FDEVENT_HUP | FDEVENT_RDHUP);
+		/* copied and modified from connection_handle_fdevent()
+		 * fdevent_is_tcp_half_closed() will fail on pipe
+		 * and, besides, read end of pipes should treat POLLHUP as POLLRDHUP */
+		n &= ~(FDEVENT_IN | FDEVENT_RDHUP);
+		rdhup = 1;
+	}
+	fdevent_fdnode_event_set(con->srv->ev, oneshot_fdn, n);
 
-static int server_oneshot_read_cq(connection *con, chunkqueue *cq, off_t max_bytes) {
-    /* temporary set con->fd to oneshot_fd (fd input) rather than outshot_fdout
-     * (lighttpd generally assumes operation on sockets, so this is a kludge) */
-    int fd = con->fd;
-    con->fd = oneshot_fdn->fd;
-    int rc = oneshot_read_cq(con, cq, max_bytes);
-    con->fd = fd;
+	fdnode *const fdn = con->fdn; /* fdn->ctx == con */
+	handler_t rc = (fdn && (fdevent_handler)NULL != fdn->handler)
+					   ? (*fdn->handler)(con, revents)
+					   : HANDLER_FINISHED;
 
-    /* note: optimistic reads (elsewhere) may or may not be enough to re-enable
-     * read interest after FDEVENT_IN interest was paused for other reasons */
+	if (rdhup)
+	{
+		r->conf.stream_request_body &=
+			~(FDEVENT_STREAM_REQUEST_BUFMIN | FDEVENT_STREAM_REQUEST_POLLIN);
+		r->conf.stream_request_body |= FDEVENT_STREAM_REQUEST_POLLRDHUP;
+		r->conf.stream_request_body |= FDEVENT_STREAM_REQUEST_TCP_FIN;
+		con->is_readable = 1; /*(can read 0 for end-of-stream)*/
+		if (chunkqueue_is_empty(con->read_queue))
+			r->keep_alive = 0;
+		if (r->reqbody_length < -1) /*(transparent proxy mode; no more data)*/
+			r->reqbody_length = r->reqbody_queue.bytes_in;
+	}
 
-    const int events = fdevent_fdnode_interest(oneshot_fdn);
-    int n = con->is_readable > 0 ? 0 : FDEVENT_IN;
-    if (events & FDEVENT_RDHUP)
-        n |= FDEVENT_RDHUP;
-    fdevent_fdnode_event_set(con->srv->ev, oneshot_fdn, n);
-    return rc;
+	return rc;
 }
 
+__attribute_cold__ static int server_oneshot_init_pipe(server *srv, int fdin, int fdout)
+{
+	/* Note: attempt to work with netcat pipes though other code expects socket.
+	 * netcat has different fds (pipes) for stdin and stdout.  To support
+	 * netcat, need to avoid S_ISSOCK(), getsockname(), and getpeername(),
+	 * reconstructing addresses from environment variables:
+	 *   NCAT_LOCAL_ADDR   NCAT_LOCAL_PORT
+	 *   NCAT_REMOTE_ADDR  NCAT_REMOTE_PORT
+	 *   NCAT_PROTO (TCP, UDP, SCTP)
+	 */
+	connection *con;
+	const server_socket *srv_socket;
+	sock_addr cnt_addr;
 
-static handler_t server_oneshot_handle_fdevent(void *context, int revents) {
-    connection *con = context;
-
-    /* note: not sync'd with con->fdn or connection_set_fdevent_interest() */
-    int rdhup = 0;
-    int n = fdevent_fdnode_interest(oneshot_fdn);
-    if (revents & FDEVENT_IN)
-        n &= ~FDEVENT_IN;
-    request_st * const r = &con->request;
-    if (r->state != CON_STATE_ERROR && (revents & (FDEVENT_HUP|FDEVENT_RDHUP))){
-        revents &= ~(FDEVENT_HUP|FDEVENT_RDHUP);
-        /* copied and modified from connection_handle_fdevent()
-         * fdevent_is_tcp_half_closed() will fail on pipe
-         * and, besides, read end of pipes should treat POLLHUP as POLLRDHUP */
-        n &= ~(FDEVENT_IN|FDEVENT_RDHUP);
-        rdhup = 1;
-    }
-    fdevent_fdnode_event_set(con->srv->ev, oneshot_fdn, n);
-
-    fdnode * const fdn = con->fdn; /* fdn->ctx == con */
-    handler_t rc = (fdn && (fdevent_handler)NULL != fdn->handler)
-      ? (*fdn->handler)(con, revents)
-      : HANDLER_FINISHED;
-
-    if (rdhup) {
-        r->conf.stream_request_body &=
-          ~(FDEVENT_STREAM_REQUEST_BUFMIN|FDEVENT_STREAM_REQUEST_POLLIN);
-        r->conf.stream_request_body |= FDEVENT_STREAM_REQUEST_POLLRDHUP;
-        r->conf.stream_request_body |= FDEVENT_STREAM_REQUEST_TCP_FIN;
-        con->is_readable = 1; /*(can read 0 for end-of-stream)*/
-        if (chunkqueue_is_empty(con->read_queue)) r->keep_alive = 0;
-        if (r->reqbody_length < -1) /*(transparent proxy mode; no more data)*/
-            r->reqbody_length = r->reqbody_queue.bytes_in;
-    }
-
-    return rc;
-}
+	/* detect if called from netcat or else fabricate localhost addrs */
+	const char *const ncat =
+		getenv("NCAT_LOCAL_ADDR");
+	const char *const ncat_local_addr =
+		ncat ? ncat : "127.0.0.1"; /*(fabricated)*/
+	const char *const ncat_local_port =
+		ncat ? getenv("NCAT_LOCAL_PORT") : "80"; /*(fabricated)*/
+	const char *const ncat_remote_addr =
+		ncat ? getenv("NCAT_REMOTE_ADDR") : "127.0.0.1"; /*(fabricated)*/
+	const char *const ncat_remote_port =
+		ncat ? getenv("NCAT_REMOTE_PORT") : "48080"; /*(fabricated)*/
+	if (NULL == ncat_local_addr || NULL == ncat_local_port)
+		return 0;
+	if (NULL == ncat_remote_addr || NULL == ncat_remote_port)
+		return 0;
 
+	const int family = ncat && strchr(ncat_local_addr, ':') ? AF_INET6 : AF_INET;
+	unsigned short port;
 
-__attribute_cold__
-static int server_oneshot_init_pipe(server *srv, int fdin, int fdout) {
-    /* Note: attempt to work with netcat pipes though other code expects socket.
-     * netcat has different fds (pipes) for stdin and stdout.  To support
-     * netcat, need to avoid S_ISSOCK(), getsockname(), and getpeername(),
-     * reconstructing addresses from environment variables:
-     *   NCAT_LOCAL_ADDR   NCAT_LOCAL_PORT
-     *   NCAT_REMOTE_ADDR  NCAT_REMOTE_PORT
-     *   NCAT_PROTO (TCP, UDP, SCTP)
-     */
-    connection *con;
-    const server_socket *srv_socket;
-    sock_addr cnt_addr;
-
-    /* detect if called from netcat or else fabricate localhost addrs */
-    const char * const ncat =
-             getenv("NCAT_LOCAL_ADDR");
-    const char * const ncat_local_addr  =
-      ncat ? ncat                       : "127.0.0.1"; /*(fabricated)*/
-    const char * const ncat_local_port  =
-      ncat ? getenv("NCAT_LOCAL_PORT")  : "80";        /*(fabricated)*/
-    const char * const ncat_remote_addr =
-      ncat ? getenv("NCAT_REMOTE_ADDR") : "127.0.0.1"; /*(fabricated)*/
-    const char * const ncat_remote_port =
-      ncat ? getenv("NCAT_REMOTE_PORT") : "48080";     /*(fabricated)*/
-    if (NULL == ncat_local_addr  || NULL == ncat_local_port)  return 0;
-    if (NULL == ncat_remote_addr || NULL == ncat_remote_port) return 0;
-
-    const int family = ncat && strchr(ncat_local_addr,':') ? AF_INET6 : AF_INET;
-    unsigned short port;
-
-    port = (unsigned short)strtol(ncat_local_port, NULL, 10);
-    if (1 != sock_addr_inet_pton(&cnt_addr, ncat_local_addr, family, port)) {
-        log_error(srv->errh, __FILE__, __LINE__, "invalid local addr");
-        return 0;
-    }
-
-    srv_socket = server_oneshot_getsock(srv, &cnt_addr);
-    if (NULL == srv_socket) return 0;
-
-    port = (unsigned short)strtol(ncat_remote_port, NULL, 10);
-    if (1 != sock_addr_inet_pton(&cnt_addr, ncat_remote_addr, family, port)) {
-        log_error(srv->errh, __FILE__, __LINE__, "invalid remote addr");
-        return 0;
-    }
-
-    /*(must set flags; fd did not pass through fdevent accept() logic)*/
-    if (-1 == fdevent_fcntl_set_nb_cloexec(fdin)) {
-        log_perror(srv->errh, __FILE__, __LINE__, "fcntl()");
-        return 0;
-    }
-    if (-1 == fdevent_fcntl_set_nb_cloexec(fdout)) {
-        log_perror(srv->errh, __FILE__, __LINE__, "fcntl()");
-        return 0;
-    }
-
-    con = connection_accepted(srv, srv_socket, &cnt_addr, fdout);
-    if (NULL == con) return 0;
-
-    /* note: existing routines assume socket, not pipe
-     * connections.c:connection_read_cq()
-     *   uses recv() ifdef _WIN32
-     *   passes S_IFSOCK to fdevent_ioctl_fionread()
-     *   (The routine could be copied and modified, if required)
-     * This is unlikely to work if TLS is used over pipe since the SSL_CTX
-     * is associated with the other end of the pipe.  However, if using
-     * pipes, using TLS is unexpected behavior.
-     */
-
-    /*assert(oneshot_fd == fdin);*/
-    oneshot_read_cq = con->network_read;
-    con->network_read = server_oneshot_read_cq;
-    oneshot_fdn =
-      fdevent_register(srv->ev, fdin, server_oneshot_handle_fdevent, con);
-    fdevent_fdnode_event_set(srv->ev, oneshot_fdn, FDEVENT_RDHUP);
-
-    connection_state_machine(con);
-    return 1;
-}
+	port = (unsigned short)strtol(ncat_local_port, NULL, 10);
+	if (1 != sock_addr_inet_pton(&cnt_addr, ncat_local_addr, family, port))
+	{
+		log_error(srv->errh, __FILE__, __LINE__, "invalid local addr");
+		return 0;
+	}
 
+	srv_socket = server_oneshot_getsock(srv, &cnt_addr);
+	if (NULL == srv_socket)
+		return 0;
 
-__attribute_cold__
-static int server_oneshot_init(server *srv, int fd) {
+	port = (unsigned short)strtol(ncat_remote_port, NULL, 10);
+	if (1 != sock_addr_inet_pton(&cnt_addr, ncat_remote_addr, family, port))
+	{
+		log_error(srv->errh, __FILE__, __LINE__, "invalid remote addr");
+		return 0;
+	}
+
+	/*(must set flags; fd did not pass through fdevent accept() logic)*/
+	if (-1 == fdevent_fcntl_set_nb_cloexec(fdin))
+	{
+		log_perror(srv->errh, __FILE__, __LINE__, "fcntl()");
+		return 0;
+	}
+	if (-1 == fdevent_fcntl_set_nb_cloexec(fdout))
+	{
+		log_perror(srv->errh, __FILE__, __LINE__, "fcntl()");
+		return 0;
+	}
+
+	con = connection_accepted(srv, srv_socket, &cnt_addr, fdout);
+	if (NULL == con)
+		return 0;
+
+	/* note: existing routines assume socket, not pipe
+	 * connections.c:connection_read_cq()
+	 *   uses recv() ifdef _WIN32
+	 *   passes S_IFSOCK to fdevent_ioctl_fionread()
+	 *   (The routine could be copied and modified, if required)
+	 * This is unlikely to work if TLS is used over pipe since the SSL_CTX
+	 * is associated with the other end of the pipe.  However, if using
+	 * pipes, using TLS is unexpected behavior.
+	 */
+
+	/*assert(oneshot_fd == fdin);*/
+	oneshot_read_cq = con->network_read;
+	con->network_read = server_oneshot_read_cq;
+	oneshot_fdn =
+		fdevent_register(srv->ev, fdin, server_oneshot_handle_fdevent, con);
+	fdevent_fdnode_event_set(srv->ev, oneshot_fdn, FDEVENT_RDHUP);
+
+	connection_state_machine(con);
+	return 1;
+}
+
+__attribute_cold__ static int server_oneshot_init(server *srv, int fd)
+{
 	connection *con;
 	const server_socket *srv_socket;
 	sock_addr cnt_addr;
 	socklen_t cnt_len;
 
 	cnt_len = sizeof(cnt_addr);
-	if (0 != getsockname(fd, (struct sockaddr *)&cnt_addr, &cnt_len)) {
+	if (0 != getsockname(fd, (struct sockaddr *)&cnt_addr, &cnt_len))
+	{
 		log_perror(srv->errh, __FILE__, __LINE__, "getsockname()");
 		return 0;
 	}
 
 	srv_socket = server_oneshot_getsock(srv, &cnt_addr);
-	if (NULL == srv_socket) return 0;
+	if (NULL == srv_socket)
+		return 0;
 
-      #ifdef __clang_analyzer__
-        memset(&cnt_addr, 0, sizeof(cnt_addr));
-      #endif
+#ifdef __clang_analyzer__
+	memset(&cnt_addr, 0, sizeof(cnt_addr));
+#endif
 	cnt_len = sizeof(cnt_addr);
-	if (0 != getpeername(fd, (struct sockaddr *)&cnt_addr, &cnt_len)) {
+	if (0 != getpeername(fd, (struct sockaddr *)&cnt_addr, &cnt_len))
+	{
 		log_perror(srv->errh, __FILE__, __LINE__, "getpeername()");
 		return 0;
 	}
 
 	/*(must set flags; fd did not pass through fdevent accept() logic)*/
-	if (-1 == fdevent_socket_set_nb_cloexec(fd)) {
+	if (-1 == fdevent_socket_set_nb_cloexec(fd))
+	{
 		log_perror(srv->errh, __FILE__, __LINE__, "fcntl()");
 		return 0;
 	}
 
-	if (sock_addr_get_family(&cnt_addr) != AF_UNIX) {
+	if (sock_addr_get_family(&cnt_addr) != AF_UNIX)
+	{
 		network_accept_tcp_nagle_disable(fd);
 	}
 
 	con = connection_accepted(srv, srv_socket, &cnt_addr, fd);
-	if (NULL == con) return 0;
+	if (NULL == con)
+		return 0;
 
 	connection_state_machine(con);
 	return 1;
 }
 
-
-__attribute_cold__
-static void show_version (void) {
-	char *b = PACKAGE_DESC TEXT_SSL \
-" - a light and fast webserver\n"
+__attribute_cold__ static void show_version(void)
+{
+	char *b = PACKAGE_DESC TEXT_SSL
+		" - a light and fast webserver\n"
 #ifdef NONREPRODUCIBLE_BUILD
-"Build-Date: " __DATE__ " " __TIME__ "\n";
+		"Build-Date: " __DATE__ " " __TIME__ "\n";
 #endif
-;
+	;
 	write_all(STDOUT_FILENO, b, strlen(b));
 }
 
-__attribute_cold__
-static void show_features (void) {
-  static const char features[] =
-      "\nFeatures:\n\n"
+__attribute_cold__ static void show_features(void)
+{
+	static const char features[] =
+		"\nFeatures:\n\n"
 #ifdef HAVE_IPV6
-      "\t+ IPv6 support\n"
+		"\t+ IPv6 support\n"
 #else
-      "\t- IPv6 support\n"
+		"\t- IPv6 support\n"
 #endif
 #if defined HAVE_ZLIB_H && defined HAVE_LIBZ
-      "\t+ zlib support\n"
+		"\t+ zlib support\n"
 #else
-      "\t- zlib support\n"
+		"\t- zlib support\n"
 #endif
 #if defined HAVE_ZSTD_H && defined HAVE_ZSTD
-      "\t+ zstd support\n"
+		"\t+ zstd support\n"
 #else
-      "\t- zstd support\n"
+		"\t- zstd support\n"
 #endif
 #if defined HAVE_BZLIB_H && defined HAVE_LIBBZ2
-      "\t+ bzip2 support\n"
+		"\t+ bzip2 support\n"
 #else
-      "\t- bzip2 support\n"
+		"\t- bzip2 support\n"
 #endif
 #if defined HAVE_BROTLI_ENCODE_H && defined HAVE_BROTLI
-      "\t+ brotli support\n"
+		"\t+ brotli support\n"
 #else
-      "\t- brotli support\n"
+		"\t- brotli support\n"
 #endif
 #if defined(HAVE_CRYPT) || defined(HAVE_CRYPT_R)
-      "\t+ crypt support\n"
+		"\t+ crypt support\n"
 #else
-      "\t- crypt support\n"
+		"\t- crypt support\n"
 #endif
 #ifdef USE_OPENSSL_CRYPTO
-      "\t+ OpenSSL support\n"
+		"\t+ OpenSSL support\n"
 #else
-      "\t- OpenSSL support\n"
+		"\t- OpenSSL support\n"
 #endif
 #ifdef USE_MBEDTLS_CRYPTO
-      "\t+ mbedTLS support\n"
+		"\t+ mbedTLS support\n"
 #else
-      "\t- mbedTLS support\n"
+		"\t- mbedTLS support\n"
 #endif
 #ifdef USE_NSS_CRYPTO
-      "\t+ NSS crypto support\n"
+		"\t+ NSS crypto support\n"
 #else
-      "\t- NSS crypto support\n"
+		"\t- NSS crypto support\n"
 #endif
 #ifdef USE_GNUTLS_CRYPTO
-      "\t+ GnuTLS support\n"
+		"\t+ GnuTLS support\n"
 #else
-      "\t- GnuTLS support\n"
+		"\t- GnuTLS support\n"
 #endif
 #ifdef USE_WOLFSSL_CRYPTO
-      "\t+ WolfSSL support\n"
+		"\t+ WolfSSL support\n"
 #else
-      "\t- WolfSSL support\n"
+		"\t- WolfSSL support\n"
 #endif
 #ifdef USE_NETTLE_CRYPTO
-      "\t+ Nettle support\n"
+		"\t+ Nettle support\n"
 #else
-      "\t- Nettle support\n"
+		"\t- Nettle support\n"
 #endif
 #ifdef HAVE_PCRE
-      "\t+ PCRE support\n"
+		"\t+ PCRE support\n"
 #else
-      "\t- PCRE support\n"
+		"\t- PCRE support\n"
 #endif
 #ifdef HAVE_MYSQL
-      "\t+ MySQL support\n"
+		"\t+ MySQL support\n"
 #else
-      "\t- MySQL support\n"
+		"\t- MySQL support\n"
 #endif
 #ifdef HAVE_PGSQL
-      "\t+ PgSQL support\n"
+		"\t+ PgSQL support\n"
 #else
-      "\t- PgSQL support\n"
+		"\t- PgSQL support\n"
 #endif
 #ifdef HAVE_DBI
-      "\t+ DBI support\n"
+		"\t+ DBI support\n"
 #else
-      "\t- DBI support\n"
+		"\t- DBI support\n"
 #endif
 #ifdef HAVE_KRB5
-      "\t+ Kerberos support\n"
+		"\t+ Kerberos support\n"
 #else
-      "\t- Kerberos support\n"
+		"\t- Kerberos support\n"
 #endif
 #if defined(HAVE_LDAP_H) && defined(HAVE_LBER_H) && defined(HAVE_LIBLDAP) && defined(HAVE_LIBLBER)
-      "\t+ LDAP support\n"
+		"\t+ LDAP support\n"
 #else
-      "\t- LDAP support\n"
+		"\t- LDAP support\n"
 #endif
 #ifdef HAVE_PAM
-      "\t+ PAM support\n"
+		"\t+ PAM support\n"
 #else
-      "\t- PAM support\n"
+		"\t- PAM support\n"
 #endif
 #ifdef HAVE_FAM_H
-      "\t+ FAM support\n"
+		"\t+ FAM support\n"
 #else
-      "\t- FAM support\n"
+		"\t- FAM support\n"
 #endif
 #ifdef HAVE_LUA_H
-      "\t+ LUA support\n"
+		"\t+ LUA support\n"
 #else
-      "\t- LUA support\n"
+		"\t- LUA support\n"
 #endif
 #ifdef HAVE_LIBXML_H
-      "\t+ xml support\n"
+		"\t+ xml support\n"
 #else
-      "\t- xml support\n"
+		"\t- xml support\n"
 #endif
 #ifdef HAVE_SQLITE3_H
-      "\t+ SQLite support\n"
+		"\t+ SQLite support\n"
 #else
-      "\t- SQLite support\n"
-#endif
-      ;
-  show_version();
-  printf("%s%s%s%s\n",
-         fdevent_show_event_handlers(),
-         network_write_show_handlers(),
-         features,
-         sizeof(time_t) > 4 || (sizeof(time_t) == 4 && (time_t)-1 > (time_t)1)
-           ? "\t+ Y2038 support\n"
-           : "\t- Y2038 support (unsafe 32-bit signed time_t)\n");
+		"\t- SQLite support\n"
+#endif
+		;
+	show_version();
+	printf("%s%s%s%s\n",
+		   fdevent_show_event_handlers(),
+		   network_write_show_handlers(),
+		   features,
+		   sizeof(time_t) > 4 || (sizeof(time_t) == 4 && (time_t)-1 > (time_t)1)
+			   ? "\t+ Y2038 support\n"
+			   : "\t- Y2038 support (unsafe 32-bit signed time_t)\n");
 }
 
-__attribute_cold__
-static void show_help (void) {
+__attribute_cold__ static void show_help(void)
+{
 	char *b = PACKAGE_DESC TEXT_SSL
 #ifdef NONREPRODUCIBLE_BUILD
-" ("__DATE__ " " __TIME__ ")"
-#endif
-" - a light and fast webserver\n" \
-"usage:\n" \
-" -f <name>  filename of the config-file\n" \
-" -m <name>  module directory (default: "LIBRARY_DIR")\n" \
-" -i <secs>  graceful shutdown after <secs> of inactivity\n" \
-" -1         process single (one) request on stdin socket, then exit\n" \
-" -p         print the parsed config-file in internal form, and exit\n" \
-" -t         test config-file syntax, then exit\n" \
-" -tt        test config-file syntax, load and init modules, then exit\n" \
-" -D         don't go to background (default: go to background)\n" \
-" -v         show version\n" \
-" -V         show compile-time features\n" \
-" -h         show this help\n" \
-"\n"
-;
+		" ("__DATE__
+		" " __TIME__ ")"
+#endif
+		" - a light and fast webserver\n"
+		"usage:\n"
+		" -f <name>  filename of the config-file\n"
+		" -m <name>  module directory (default: " LIBRARY_DIR ")\n"
+		" -i <secs>  graceful shutdown after <secs> of inactivity\n"
+		" -1         process single (one) request on stdin socket, then exit\n"
+		" -p         print the parsed config-file in internal form, and exit\n"
+		" -t         test config-file syntax, then exit\n"
+		" -tt        test config-file syntax, load and init modules, then exit\n"
+		" -D         don't go to background (default: go to background)\n"
+		" -v         show version\n"
+		" -V         show compile-time features\n"
+		" -h         show this help\n"
+		"\n";
 	write_all(STDOUT_FILENO, b, strlen(b));
 }
 
 __attribute_cold__
-__attribute_noinline__
-static void server_sockets_save (server *srv) {    /* graceful_restart */
-    for (uint32_t i = 0; i < srv->srv_sockets.used; ++i)
-        srv->srv_sockets.ptr[i]->srv = NULL; /* srv will shortly be invalid */
-    for (uint32_t i = 0; i < srv->srv_sockets_inherited.used; ++i)
-        srv->srv_sockets_inherited.ptr[i]->srv = NULL; /* srv to be invalid */
-    memcpy(&graceful_sockets, &srv->srv_sockets, sizeof(server_socket_array));
-    memset(&srv->srv_sockets, 0, sizeof(server_socket_array));
-    memcpy(&inherited_sockets, &srv->srv_sockets_inherited, sizeof(server_socket_array));
-    memset(&srv->srv_sockets_inherited, 0, sizeof(server_socket_array));
+	__attribute_noinline__ static void
+	server_sockets_save(server *srv)
+{ /* graceful_restart */
+	for (uint32_t i = 0; i < srv->srv_sockets.used; ++i)
+		srv->srv_sockets.ptr[i]->srv = NULL; /* srv will shortly be invalid */
+	for (uint32_t i = 0; i < srv->srv_sockets_inherited.used; ++i)
+		srv->srv_sockets_inherited.ptr[i]->srv = NULL; /* srv to be invalid */
+	memcpy(&graceful_sockets, &srv->srv_sockets, sizeof(server_socket_array));
+	memset(&srv->srv_sockets, 0, sizeof(server_socket_array));
+	memcpy(&inherited_sockets, &srv->srv_sockets_inherited, sizeof(server_socket_array));
+	memset(&srv->srv_sockets_inherited, 0, sizeof(server_socket_array));
 }
 
 __attribute_cold__
-__attribute_noinline__
-static void server_sockets_restore (server *srv) { /* graceful_restart */
-    memcpy(&srv->srv_sockets, &graceful_sockets, sizeof(server_socket_array));
-    memset(&graceful_sockets, 0, sizeof(server_socket_array));
-    memcpy(&srv->srv_sockets_inherited, &inherited_sockets, sizeof(server_socket_array));
-    memset(&inherited_sockets, 0, sizeof(server_socket_array));
-    for (uint32_t i = 0; i < srv->srv_sockets.used; ++i) {
-        srv->srv_sockets.ptr[i]->srv = srv;           /* update ptr */
-        srv->srv_sockets.ptr[i]->sidx= (unsigned short)~0u;
-    }
-    for (uint32_t i = 0; i < srv->srv_sockets_inherited.used; ++i)
-        srv->srv_sockets_inherited.ptr[i]->srv = srv; /* update ptr */
+	__attribute_noinline__ static void
+	server_sockets_restore(server *srv)
+{ /* graceful_restart */
+	memcpy(&srv->srv_sockets, &graceful_sockets, sizeof(server_socket_array));
+	memset(&graceful_sockets, 0, sizeof(server_socket_array));
+	memcpy(&srv->srv_sockets_inherited, &inherited_sockets, sizeof(server_socket_array));
+	memset(&inherited_sockets, 0, sizeof(server_socket_array));
+	for (uint32_t i = 0; i < srv->srv_sockets.used; ++i)
+	{
+		srv->srv_sockets.ptr[i]->srv = srv; /* update ptr */
+		srv->srv_sockets.ptr[i]->sidx = (unsigned short)~0u;
+	}
+	for (uint32_t i = 0; i < srv->srv_sockets_inherited.used; ++i)
+		srv->srv_sockets_inherited.ptr[i]->srv = srv; /* update ptr */
 }
 
-__attribute_cold__
-static int server_sockets_set_nb_cloexec (server *srv) {
-    if (srv->sockets_disabled) return 0; /* lighttpd -1 (one-shot mode) */
-    for (uint32_t i = 0; i < srv->srv_sockets.used; ++i) {
-        server_socket *srv_socket = srv->srv_sockets.ptr[i];
-        if (-1 == fdevent_fcntl_set_nb_cloexec_sock(srv_socket->fd)) {
-            log_perror(srv->errh, __FILE__, __LINE__, "fcntl()");
-            return -1;
-        }
-    }
-    return 0;
+__attribute_cold__ static int server_sockets_set_nb_cloexec(server *srv)
+{
+	if (srv->sockets_disabled)
+		return 0; /* lighttpd -1 (one-shot mode) */
+	for (uint32_t i = 0; i < srv->srv_sockets.used; ++i)
+	{
+		server_socket *srv_socket = srv->srv_sockets.ptr[i];
+		if (-1 == fdevent_fcntl_set_nb_cloexec_sock(srv_socket->fd))
+		{
+			log_perror(srv->errh, __FILE__, __LINE__, "fcntl()");
+			return -1;
+		}
+	}
+	return 0;
 }
 
-__attribute_cold__
-static void server_sockets_set_event (server *srv, int event) {
-    for (uint32_t i = 0; i < srv->srv_sockets.used; ++i) {
-        server_socket *srv_socket = srv->srv_sockets.ptr[i];
-        fdevent_fdnode_event_set(srv->ev, srv_socket->fdn, event);
-    }
+__attribute_cold__ static void server_sockets_set_event(server *srv, int event)
+{
+	for (uint32_t i = 0; i < srv->srv_sockets.used; ++i)
+	{
+		server_socket *srv_socket = srv->srv_sockets.ptr[i];
+		fdevent_fdnode_event_set(srv->ev, srv_socket->fdn, event);
+	}
 }
 
-__attribute_cold__
-static void server_sockets_unregister (server *srv) {
-    if (2 == srv->sockets_disabled) return;
-    srv->sockets_disabled = 2;
-    for (uint32_t i = 0; i < srv->srv_sockets.used; ++i)
-        network_unregister_sock(srv, srv->srv_sockets.ptr[i]);
+__attribute_cold__ static void server_sockets_unregister(server *srv)
+{
+	if (2 == srv->sockets_disabled)
+		return;
+	srv->sockets_disabled = 2;
+	for (uint32_t i = 0; i < srv->srv_sockets.used; ++i)
+		network_unregister_sock(srv, srv->srv_sockets.ptr[i]);
 }
 
-__attribute_cold__
-static void server_sockets_close (server *srv) {
-    /* closing socket right away will make it possible for the next lighttpd
-     * to take over (old-style graceful restart), but only if backends
-     * (e.g. fastcgi, scgi, etc) are independent from lighttpd, rather
-     * than started by lighttpd via "bin-path")
-     */
-    if (3 == srv->sockets_disabled) return;
-    for (uint32_t i = 0; i < srv->srv_sockets.used; ++i) {
-        server_socket *srv_socket = srv->srv_sockets.ptr[i];
-        if (-1 == srv_socket->fd) continue;
-        if (2 != srv->sockets_disabled) network_unregister_sock(srv,srv_socket);
-        fdio_close_socket(srv_socket->fd);
-        srv_socket->fd = -1;
-        /* network_close() will cleanup after us */
-    }
-    srv->sockets_disabled = 3;
+__attribute_cold__ static void server_sockets_close(server *srv)
+{
+	/* closing socket right away will make it possible for the next lighttpd
+	 * to take over (old-style graceful restart), but only if backends
+	 * (e.g. fastcgi, scgi, etc) are independent from lighttpd, rather
+	 * than started by lighttpd via "bin-path")
+	 */
+	if (3 == srv->sockets_disabled)
+		return;
+	for (uint32_t i = 0; i < srv->srv_sockets.used; ++i)
+	{
+		server_socket *srv_socket = srv->srv_sockets.ptr[i];
+		if (-1 == srv_socket->fd)
+			continue;
+		if (2 != srv->sockets_disabled)
+			network_unregister_sock(srv, srv_socket);
+		fdio_close_socket(srv_socket->fd);
+		srv_socket->fd = -1;
+		/* network_close() will cleanup after us */
+	}
+	srv->sockets_disabled = 3;
 }
 
-__attribute_cold__
-static void server_graceful_signal_prev_generation (void)
+__attribute_cold__ static void server_graceful_signal_prev_generation(void)
 {
-  #ifdef HAVE_FORK
-    const char * const prev_gen = getenv("LIGHTTPD_PREV_GEN");
-    if (NULL == prev_gen) return;
-    pid_t pid = (pid_t)strtol(prev_gen, NULL, 10);
-    unsetenv("LIGHTTPD_PREV_GEN");
-    if (pid <= 0) return; /*(should not happen)*/
-    if (pid == fdevent_waitpid(pid,NULL,1)) return; /*(pid exited; unexpected)*/
-    kill(pid, SIGINT); /* signal previous generation for graceful shutdown */
-  #endif
+#ifdef HAVE_FORK
+	const char *const prev_gen = getenv("LIGHTTPD_PREV_GEN");
+	if (NULL == prev_gen)
+		return;
+	pid_t pid = (pid_t)strtol(prev_gen, NULL, 10);
+	unsetenv("LIGHTTPD_PREV_GEN");
+	if (pid <= 0)
+		return; /*(should not happen)*/
+	if (pid == fdevent_waitpid(pid, NULL, 1))
+		return;		   /*(pid exited; unexpected)*/
+	kill(pid, SIGINT); /* signal previous generation for graceful shutdown */
+#endif
 }
 
-__attribute_cold__
-static int server_graceful_state_bg (server *srv) {
-    /*assert(graceful_restart);*/
-    /*(SIGUSR1 set to SIG_IGN in workers, so should not reach here if worker)*/
-    if (srv_shutdown) return 0;
-
-    /* check if server should fork and background (bg) itself
-     * to continue processing requests already in progress */
-    if (!config_feature_bool(srv, "server.graceful-restart-bg", 0)) return 0;
-
-    /*(set flag to false to avoid repeating)*/
-    data_unset * const du =
-      array_get_data_unset(srv->srvconf.feature_flags,
-                           CONST_STR_LEN("server.graceful-restart-bg"));
-    if (du->type == TYPE_STRING)
-        buffer_copy_string_len(&((data_string *)du)->value,
-                               CONST_STR_LEN("false"));
-    else /* (du->type == TYPE_INTEGER) */
-        ((data_integer *)du)->value = 0;
-
-    /* require exec'd via absolute path or daemon in foreground
-     * and exec'd with path containing '/' (e.g. "./xxxxx") */
-    char ** const argv = srv->argv;
-    if (0 == srv->srvconf.dont_daemonize
-        ? argv[0][0] != '/'
-        : NULL == strchr(argv[0], '/')) return 0;
-
-    /* flush log buffers to avoid potential duplication of entries
-     * server_handle_sighup(srv) does the following, but skip logging */
-    plugins_call_handle_sighup(srv);
-    fdlog_files_cycle(srv->errh); /* reopen log files, not pipes */
-
-    /* backgrounding to continue processing requests in progress */
-    /* re-exec lighttpd in original process
-     *   Note: using path in re-exec is portable and allows lighttpd upgrade.
-     *   OTOH, getauxval() AT_EXECFD and fexecve() could be used on Linux to
-     *   re-exec without access to original executable on disk, which might be
-     *   desirable in some situations, but is not implemented here.
-     *   Alternatively, if argv[] was not available, could use readlink() on
-     *   /proc/self/exe (Linux-specific), though there are ways on many other
-     *   platforms to achieve the same:
-     *   https://stackoverflow.com/questions/1023306/finding-current-executables-path-without-proc-self-exe
-     */
-  #if defined(HAVE_KQUEUE)
-   #if defined(__FreeBSD__) || defined(__DragonFly__)
-    /*(must *exclude* rfork RFFDG flag for kqueue to work across rfork)*/
-    pid_t pid = rfork(RFPROC);
-   #else
-    pid_t pid = -1;
-    if (pid < 0) {
-        /* kqueue is not inherited across fork
-         * future: fdevent kqueue and stat_cache kqueue would need to be closed,
-         *         re-opened, and active fds re-registered.  Not current done.
-         *         Need to create some routines like fdevent_reinit_after_fork*/
-        log_error(srv->errh, __FILE__, __LINE__,
-          "server.graceful-restart-bg ignored on OpenBSD and NetBSD "
-          "due to limitation in kqueue inheritance and lacking rfork");
-        return 0;
-    }
-   #endif
-  #elif defined(HAVE_FORK)
-    pid_t pid = fork();
-  #else
-    pid_t pid = -1;
-  #endif
-    if (pid) { /* original process */
-        if (pid < 0) return 0;
-        network_socket_activation_to_env(srv);
-        /* save pid of original server in environment so that it can be
-         * signalled by restarted server once restarted server is ready
-         * to accept new connections */
-        server_graceful_signal_prev_generation();/*(expect no prev gen active)*/
-        if (0 == srv->srvconf.max_worker) {
-            buffer * const tb = srv->tmp_buf;
-            buffer_clear(tb);
-            buffer_append_int(tb, pid);
-            setenv("LIGHTTPD_PREV_GEN", tb->ptr, 1);
-        }
-        /*fdevent_waitpid(pid, NULL, 0);*//* detach? */
-        execv(argv[0], argv);
-        _exit(1);
-    }
-    /* else child/grandchild */
-
-    /*if (-1 == setsid()) _exit(1);*//* should we detach? */
-    /* Note: restarted server will fail with socket-in-use error if
-     *       server.systemd-socket-activation not enabled in restarted server */
-    if (0 != srv->srvconf.max_worker)
-        server_sockets_close(srv);/*(close before parent reaps pid in waitpid)*/
-    /*if (0 != fork())    _exit(0);*//* should we detach? */
-    /*(grandchild is now backgrounded and detached from original process)*/
-
-    /* XXX: might extend code to have new server.feature-flags param specify
-     *      max lifetime before aborting remaining connections */
-
-    /* (reached if lighttpd workers or if sole process w/o workers)
-     * use same code as comment elsewhere in server.c:
-     *   make sure workers do not muck with pid-file */
-    if (0 <= pid_fd) {
-            close(pid_fd);
-            pid_fd = -1;
-    }
-    srv->srvconf.pid_file = NULL;
-
-    /* (original process is backgrounded -- even if no active connections --
-     *  to allow graceful shutdown tasks to be run by server and by modules) */
-    log_error(srv->errh, __FILE__, __LINE__,
-      "[note] pid %lld continuing to handle %u connection(s) in progress",
-      (long long)getpid(), srv->srvconf.max_conns - srv->lim_conns);
-
-    if (0 == srv->srvconf.max_worker) {
-        /* reset graceful_shutdown; wait for signal from restarted server */
-        srv->graceful_expire_ts = 0;
-        graceful_shutdown = 0;
-    }
-    graceful_restart = 0;
-    return 1;
+__attribute_cold__ static int server_graceful_state_bg(server *srv)
+{
+	/*assert(graceful_restart);*/
+	/*(SIGUSR1 set to SIG_IGN in workers, so should not reach here if worker)*/
+	if (srv_shutdown)
+		return 0;
+
+	/* check if server should fork and background (bg) itself
+	 * to continue processing requests already in progress */
+	if (!config_feature_bool(srv, "server.graceful-restart-bg", 0))
+		return 0;
+
+	/*(set flag to false to avoid repeating)*/
+	data_unset *const du =
+		array_get_data_unset(srv->srvconf.feature_flags,
+							 CONST_STR_LEN("server.graceful-restart-bg"));
+	if (du->type == TYPE_STRING)
+		buffer_copy_string_len(&((data_string *)du)->value,
+							   CONST_STR_LEN("false"));
+	else /* (du->type == TYPE_INTEGER) */
+		((data_integer *)du)->value = 0;
+
+	/* require exec'd via absolute path or daemon in foreground
+	 * and exec'd with path containing '/' (e.g. "./xxxxx") */
+	char **const argv = srv->argv;
+	if (0 == srv->srvconf.dont_daemonize
+			? argv[0][0] != '/'
+			: NULL == strchr(argv[0], '/'))
+		return 0;
+
+	/* flush log buffers to avoid potential duplication of entries
+	 * server_handle_sighup(srv) does the following, but skip logging */
+	plugins_call_handle_sighup(srv);
+	fdlog_files_cycle(srv->errh); /* reopen log files, not pipes */
+
+	/* backgrounding to continue processing requests in progress */
+	/* re-exec lighttpd in original process
+	 *   Note: using path in re-exec is portable and allows lighttpd upgrade.
+	 *   OTOH, getauxval() AT_EXECFD and fexecve() could be used on Linux to
+	 *   re-exec without access to original executable on disk, which might be
+	 *   desirable in some situations, but is not implemented here.
+	 *   Alternatively, if argv[] was not available, could use readlink() on
+	 *   /proc/self/exe (Linux-specific), though there are ways on many other
+	 *   platforms to achieve the same:
+	 *   https://stackoverflow.com/questions/1023306/finding-current-executables-path-without-proc-self-exe
+	 */
+#if defined(HAVE_KQUEUE)
+#if defined(__FreeBSD__) || defined(__DragonFly__)
+	/*(must *exclude* rfork RFFDG flag for kqueue to work across rfork)*/
+	pid_t pid = rfork(RFPROC);
+#else
+	pid_t pid = -1;
+	if (pid < 0)
+	{
+		/* kqueue is not inherited across fork
+		 * future: fdevent kqueue and stat_cache kqueue would need to be closed,
+		 *         re-opened, and active fds re-registered.  Not current done.
+		 *         Need to create some routines like fdevent_reinit_after_fork*/
+		log_error(srv->errh, __FILE__, __LINE__,
+				  "server.graceful-restart-bg ignored on OpenBSD and NetBSD "
+				  "due to limitation in kqueue inheritance and lacking rfork");
+		return 0;
+	}
+#endif
+#elif defined(HAVE_FORK)
+	pid_t pid = fork();
+#else
+	pid_t pid = -1;
+#endif
+	if (pid)
+	{ /* original process */
+		if (pid < 0)
+			return 0;
+		network_socket_activation_to_env(srv);
+		/* save pid of original server in environment so that it can be
+		 * signalled by restarted server once restarted server is ready
+		 * to accept new connections */
+		server_graceful_signal_prev_generation(); /*(expect no prev gen active)*/
+		if (0 == srv->srvconf.max_worker)
+		{
+			buffer *const tb = srv->tmp_buf;
+			buffer_clear(tb);
+			buffer_append_int(tb, pid);
+			setenv("LIGHTTPD_PREV_GEN", tb->ptr, 1);
+		}
+		/*fdevent_waitpid(pid, NULL, 0);*/ /* detach? */
+		execv(argv[0], argv);
+		_exit(1);
+	}
+	/* else child/grandchild */
+
+	/*if (-1 == setsid()) _exit(1);*/ /* should we detach? */
+	/* Note: restarted server will fail with socket-in-use error if
+	 *       server.systemd-socket-activation not enabled in restarted server */
+	if (0 != srv->srvconf.max_worker)
+		server_sockets_close(srv);	  /*(close before parent reaps pid in waitpid)*/
+	/*if (0 != fork())    _exit(0);*/ /* should we detach? */
+	/*(grandchild is now backgrounded and detached from original process)*/
+
+	/* XXX: might extend code to have new server.feature-flags param specify
+	 *      max lifetime before aborting remaining connections */
+
+	/* (reached if lighttpd workers or if sole process w/o workers)
+	 * use same code as comment elsewhere in server.c:
+	 *   make sure workers do not muck with pid-file */
+	if (0 <= pid_fd)
+	{
+		close(pid_fd);
+		pid_fd = -1;
+	}
+	srv->srvconf.pid_file = NULL;
+
+	/* (original process is backgrounded -- even if no active connections --
+	 *  to allow graceful shutdown tasks to be run by server and by modules) */
+	log_error(srv->errh, __FILE__, __LINE__,
+			  "[note] pid %lld continuing to handle %u connection(s) in progress",
+			  (long long)getpid(), srv->srvconf.max_conns - srv->lim_conns);
+
+	if (0 == srv->srvconf.max_worker)
+	{
+		/* reset graceful_shutdown; wait for signal from restarted server */
+		srv->graceful_expire_ts = 0;
+		graceful_shutdown = 0;
+	}
+	graceful_restart = 0;
+	return 1;
 }
 
 __attribute_cold__
-__attribute_noinline__
-static void server_graceful_shutdown_maint (server *srv) {
-    if (oneshot_fd) {
-        /* permit keep-alive on one-shot connections until graceful_expire_ts */
-        if (!srv->graceful_expire_ts) return;
-        if (srv->graceful_expire_ts >= log_monotonic_secs) return;
-    }
-    connection_graceful_shutdown_maint(srv);
+	__attribute_noinline__ static void
+	server_graceful_shutdown_maint(server *srv)
+{
+	if (oneshot_fd)
+	{
+		/* permit keep-alive on one-shot connections until graceful_expire_ts */
+		if (!srv->graceful_expire_ts)
+			return;
+		if (srv->graceful_expire_ts >= log_monotonic_secs)
+			return;
+	}
+	connection_graceful_shutdown_maint(srv);
 }
 
 #ifndef server_status_stopping
-#define server_status_stopping(srv) do { } while (0)
+#define server_status_stopping(srv) \
+	do                              \
+	{                               \
+	} while (0)
 #endif
 
 __attribute_cold__
-__attribute_noinline__
-static void server_graceful_state (server *srv) {
-
-    if (!srv_shutdown) {
-        if (0 == srv->graceful_expire_ts) {
-            srv->graceful_expire_ts =
-              config_feature_int(srv, "server.graceful-shutdown-timeout", 8);
-            if (srv->graceful_expire_ts)
-                srv->graceful_expire_ts += log_monotonic_secs;
-        }
-        server_graceful_shutdown_maint(srv);
-    }
-
-    server_status_stopping(srv);/*might be called multiple times; intentional*/
-
-    if (2 == srv->sockets_disabled || 3 == srv->sockets_disabled) {
-        if (oneshot_fd) graceful_restart = 0;
-        return;
-    }
-
-    log_error(srv->errh,__FILE__,__LINE__,"[note] graceful shutdown started");
-
-    /* no graceful restart if chroot()ed, if oneshot mode, or if idle timeout */
-    if (srv->srvconf.changeroot || oneshot_fd || 2 == graceful_shutdown)
-        graceful_restart = 0;
-
-    if (graceful_restart) {
-        if (!server_graceful_state_bg(srv))
-            server_sockets_unregister(srv);
-        if (pid_fd > 0) pid_fd = -pid_fd; /*(flag to skip removing pid file)*/
-    }
-    else {
-        server_sockets_close(srv);
-        remove_pid_file(srv);
-        /*(prevent more removal attempts)*/
-        srv->srvconf.pid_file = NULL;
-    }
+	__attribute_noinline__ static void
+	server_graceful_state(server *srv)
+{
+
+	if (!srv_shutdown)
+	{
+		if (0 == srv->graceful_expire_ts)
+		{
+			srv->graceful_expire_ts =
+				config_feature_int(srv, "server.graceful-shutdown-timeout", 8);
+			if (srv->graceful_expire_ts)
+				srv->graceful_expire_ts += log_monotonic_secs;
+		}
+		server_graceful_shutdown_maint(srv);
+	}
+
+	server_status_stopping(srv); /*might be called multiple times; intentional*/
+
+	if (2 == srv->sockets_disabled || 3 == srv->sockets_disabled)
+	{
+		if (oneshot_fd)
+			graceful_restart = 0;
+		return;
+	}
+
+	log_error(srv->errh, __FILE__, __LINE__, "[note] graceful shutdown started");
+
+	/* no graceful restart if chroot()ed, if oneshot mode, or if idle timeout */
+	if (srv->srvconf.changeroot || oneshot_fd || 2 == graceful_shutdown)
+		graceful_restart = 0;
+
+	if (graceful_restart)
+	{
+		if (!server_graceful_state_bg(srv))
+			server_sockets_unregister(srv);
+		if (pid_fd > 0)
+			pid_fd = -pid_fd; /*(flag to skip removing pid file)*/
+	}
+	else
+	{
+		server_sockets_close(srv);
+		remove_pid_file(srv);
+		/*(prevent more removal attempts)*/
+		srv->srvconf.pid_file = NULL;
+	}
 }
 
 __attribute_cold__
-__attribute_noinline__
-static void server_sockets_enable (server *srv) {
-    server_sockets_set_event(srv, FDEVENT_IN);
-    srv->sockets_disabled = 0;
-    log_error(srv->errh, __FILE__, __LINE__, "[note] sockets enabled again");
+	__attribute_noinline__ static void
+	server_sockets_enable(server *srv)
+{
+	server_sockets_set_event(srv, FDEVENT_IN);
+	srv->sockets_disabled = 0;
+	log_error(srv->errh, __FILE__, __LINE__, "[note] sockets enabled again");
 }
 
 __attribute_cold__
-__attribute_noinline__
-static void server_sockets_disable (server *srv) {
-    server_sockets_set_event(srv, 0);
-    srv->sockets_disabled = 1;
-    log_error(srv->errh, __FILE__, __LINE__,
-      (0 == srv->lim_conns)
-        ? "[note] sockets disabled, connection limit reached"
-        : "[note] sockets disabled, out-of-fds");
+	__attribute_noinline__ static void
+	server_sockets_disable(server *srv)
+{
+	server_sockets_set_event(srv, 0);
+	srv->sockets_disabled = 1;
+	log_error(srv->errh, __FILE__, __LINE__,
+			  (0 == srv->lim_conns)
+				  ? "[note] sockets disabled, connection limit reached"
+				  : "[note] sockets disabled, out-of-fds");
 }
 
-__attribute_cold__
-static void server_overload_check (server *srv) {
-    if (srv->cur_fds < srv->max_fds_lowat && 0 != srv->lim_conns)
-        server_sockets_enable(srv);
+__attribute_cold__ static void server_overload_check(server *srv)
+{
+	if (srv->cur_fds < srv->max_fds_lowat && 0 != srv->lim_conns)
+		server_sockets_enable(srv);
 }
 
-static void server_load_check (server *srv) {
-    /* check if hit limits for num fds used or num connections */
-    if (srv->cur_fds > srv->max_fds_hiwat || 0 == srv->lim_conns)
-        server_sockets_disable(srv);
+static void server_load_check(server *srv)
+{
+	/* check if hit limits for num fds used or num connections */
+	if (srv->cur_fds > srv->max_fds_hiwat || 0 == srv->lim_conns)
+		server_sockets_disable(srv);
 }
 
 #ifdef HAVE_FORK
-__attribute_noinline__
-static int server_main_setup_workers (server * const srv, const int npids) {
-    pid_t pid;
-    int num_childs = npids;
-    int child = 0;
-    unsigned int timer = 0;
-    pid_t pids[npids];
-    for (int n = 0; n < npids; ++n) pids[n] = -1;
-    server_graceful_signal_prev_generation();
-    while (!child && !srv_shutdown && !graceful_shutdown) {
-        if (num_childs > 0) {
-            switch ((pid = fork())) {
-              case -1:
-                return -1;
-              case 0:
-                child = 1;
-                alarm(0);
-                break;
-              default:
-                num_childs--;
-                for (int n = 0; n < npids; ++n) {
-                    if (-1 == pids[n]) {
-                        pids[n] = pid;
-                        break;
-                    }
-                }
-                break;
-            }
-        }
-        else {
-            int status;
-            unix_time64_t mono_ts;
-            if (-1 != (pid = fdevent_waitpid_intr(-1, &status))) {
-                mono_ts = log_monotonic_secs;
-                log_monotonic_secs = server_monotonic_secs();
-                log_epoch_secs =
-                  server_epoch_secs(srv, log_monotonic_secs - mono_ts);
-                if (plugins_call_handle_waitpid(srv, pid, status)
-                    != HANDLER_GO_ON) {
-                    if (!timer) alarm((timer = 5));
-                    continue;
-                }
-                switch (fdlog_pipes_waitpid_cb(pid)) {
-                  default: break;
-                  case -1: if (!timer) alarm((timer = 5));
-                           __attribute_fallthrough__
-                  case  1: continue;
-                }
-                /**
-                 * check if one of our workers went away
-                 */
-                for (int n = 0; n < npids; ++n) {
-                    if (pid == pids[n]) {
-                        pids[n] = -1;
-                        num_childs++;
-                        break;
-                    }
-                }
-            }
-            else if (errno == EINTR) {
-                mono_ts = log_monotonic_secs;
-                log_monotonic_secs = server_monotonic_secs();
-                log_epoch_secs =
-                  server_epoch_secs(srv, log_monotonic_secs - mono_ts);
-                /* On SIGHUP, cycle logs (periodic maint runs in children) */
-                if (handle_sig_hup) {
-                    handle_sig_hup = 0;
-                    fdlog_files_cycle(srv->errh);/*reopen log files, not pipes*/
-                    /* forward SIGHUP to workers */
-                    for (int n = 0; n < npids; ++n) {
-                        if (pids[n] > 0) kill(pids[n], SIGHUP);
-                    }
-                }
-                if (handle_sig_alarm) {
-                    handle_sig_alarm = 0;
-                    timer = 0;
-                    plugins_call_handle_trigger(srv);
-                    fdlog_pipes_restart(log_monotonic_secs);
-                }
-            }
-        }
-    }
-
-    if (!child) {
-        /* exit point for parent monitoring workers;
-         * signal children, too */
-        if (graceful_shutdown || graceful_restart) {
-            /* flag to ignore one SIGINT if graceful_restart */
-            if (graceful_restart) graceful_restart = 2;
-            kill(0, SIGINT);
-            server_graceful_state(srv);
-        }
-        else if (srv_shutdown)
-            kill(0, SIGTERM);
-
-        return 0;
-    }
-
-    /* ignore SIGUSR1 in workers; only parent directs graceful restart */
-  #ifdef HAVE_SIGACTION
-    struct sigaction actignore;
-    memset(&actignore, 0, sizeof(actignore));
-    actignore.sa_handler = SIG_IGN;
-    sigaction(SIGUSR1, &actignore, NULL);
-  #elif defined(HAVE_SIGNAL)
-    signal(SIGUSR1, SIG_IGN);
-  #endif
-
-    /**
-     * make sure workers do not muck with pid-file
-     */
-    if (0 <= pid_fd) {
-        close(pid_fd);
-        pid_fd = -1;
-    }
-    srv->srvconf.pid_file = NULL;
-
-    fdlog_pipes_abandon_pids();
-    srv->pid = getpid();
-    li_rand_reseed();
-
-    return 1; /* child worker */
+__attribute_noinline__ static int server_main_setup_workers(server *const srv, const int npids)
+{
+	pid_t pid;
+	int num_childs = npids;
+	int child = 0;
+	unsigned int timer = 0;
+	pid_t pids[npids];
+	for (int n = 0; n < npids; ++n)
+		pids[n] = -1;
+	server_graceful_signal_prev_generation();
+	while (!child && !srv_shutdown && !graceful_shutdown)
+	{
+		if (num_childs > 0)
+		{
+			switch ((pid = fork()))
+			{
+			case -1:
+				return -1;
+			case 0:
+				child = 1;
+				alarm(0);
+				break;
+			default:
+				num_childs--;
+				for (int n = 0; n < npids; ++n)
+				{
+					if (-1 == pids[n])
+					{
+						pids[n] = pid;
+						break;
+					}
+				}
+				break;
+			}
+		}
+		else
+		{
+			int status;
+			unix_time64_t mono_ts;
+			if (-1 != (pid = fdevent_waitpid_intr(-1, &status)))
+			{
+				mono_ts = log_monotonic_secs;
+				log_monotonic_secs = server_monotonic_secs();
+				log_epoch_secs =
+					server_epoch_secs(srv, log_monotonic_secs - mono_ts);
+				if (plugins_call_handle_waitpid(srv, pid, status) != HANDLER_GO_ON)
+				{
+					if (!timer)
+						alarm((timer = 5));
+					continue;
+				}
+				switch (fdlog_pipes_waitpid_cb(pid))
+				{
+				default:
+					break;
+				case -1:
+					if (!timer)
+						alarm((timer = 5));
+				__attribute_fallthrough__ case 1:
+					continue;
+				}
+				/**
+				 * check if one of our workers went away
+				 */
+				for (int n = 0; n < npids; ++n)
+				{
+					if (pid == pids[n])
+					{
+						pids[n] = -1;
+						num_childs++;
+						break;
+					}
+				}
+			}
+			else if (errno == EINTR)
+			{
+				mono_ts = log_monotonic_secs;
+				log_monotonic_secs = server_monotonic_secs();
+				log_epoch_secs =
+					server_epoch_secs(srv, log_monotonic_secs - mono_ts);
+				/* On SIGHUP, cycle logs (periodic maint runs in children) */
+				if (handle_sig_hup)
+				{
+					handle_sig_hup = 0;
+					fdlog_files_cycle(srv->errh); /*reopen log files, not pipes*/
+					/* forward SIGHUP to workers */
+					for (int n = 0; n < npids; ++n)
+					{
+						if (pids[n] > 0)
+							kill(pids[n], SIGHUP);
+					}
+				}
+				if (handle_sig_alarm)
+				{
+					handle_sig_alarm = 0;
+					timer = 0;
+					plugins_call_handle_trigger(srv);
+					fdlog_pipes_restart(log_monotonic_secs);
+				}
+			}
+		}
+	}
+
+	if (!child)
+	{
+		/* exit point for parent monitoring workers;
+		 * signal children, too */
+		if (graceful_shutdown || graceful_restart)
+		{
+			/* flag to ignore one SIGINT if graceful_restart */
+			if (graceful_restart)
+				graceful_restart = 2;
+			kill(0, SIGINT);
+			server_graceful_state(srv);
+		}
+		else if (srv_shutdown)
+			kill(0, SIGTERM);
+
+		return 0;
+	}
+
+	/* ignore SIGUSR1 in workers; only parent directs graceful restart */
+#ifdef HAVE_SIGACTION
+	struct sigaction actignore;
+	memset(&actignore, 0, sizeof(actignore));
+	actignore.sa_handler = SIG_IGN;
+	sigaction(SIGUSR1, &actignore, NULL);
+#elif defined(HAVE_SIGNAL)
+	signal(SIGUSR1, SIG_IGN);
+#endif
+
+	/**
+	 * make sure workers do not muck with pid-file
+	 */
+	if (0 <= pid_fd)
+	{
+		close(pid_fd);
+		pid_fd = -1;
+	}
+	srv->srvconf.pid_file = NULL;
+
+	fdlog_pipes_abandon_pids();
+	srv->pid = getpid();
+	li_rand_reseed();
+
+	return 1; /* child worker */
 }
 #endif
 
 __attribute_cold__
-__attribute_noinline__
-static int server_main_setup (server * const srv, int argc, char **argv) {
+	__attribute_noinline__ static int
+	server_main_setup(server *const srv, int argc, char **argv)
+{
 	int print_config = 0;
 	int test_config = 0;
 	int i_am_root = 0;
@@ -1412,160 +1553,199 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 	handle_sig_hup = 0;
 	idle_limit = 0;
 	chunkqueue_set_tempdirs_default_reset();
-	/*graceful_restart = 0;*//*(reset below to avoid further daemonizing)*/
+	/*graceful_restart = 0;*/ /*(reset below to avoid further daemonizing)*/
 	/*(intentionally preserved)*/
 	/*memset(graceful_sockets, 0, sizeof(graceful_sockets));*/
 	/*memset(inherited_sockets, 0, sizeof(inherited_sockets));*/
 	/*pid_fd = -1;*/
 	srv->argv = argv;
 
-	for (int o; -1 != (o = getopt(argc, argv, "f:m:i:hvVD1pt")); ) {
-		switch(o) {
+	for (int o; -1 != (o = getopt(argc, argv, "f:m:i:hvVD1pt"));)
+	{
+		switch (o)
+		{
 		case 'f':
-			if (srv->config_data_base) {
+			if (srv->config_data_base)
+			{
 				log_error(srv->errh, __FILE__, __LINE__,
-				  "Can only read one config file. Use the include command to use multiple config files.");
+						  "Can only read one config file. Use the include command to use multiple config files.");
 				return -1;
 			}
-			if (config_read(srv, optarg)) {
+			if (config_read(srv, optarg))
+			{
 				return -1;
 			}
 			break;
 		case 'm':
 			srv->srvconf.modules_dir = optarg;
 			break;
-		case 'i': {
+		case 'i':
+		{
 			char *endptr;
 			long timeout = strtol(optarg, &endptr, 0);
-			if (!*optarg || *endptr || timeout < 0) {
+			if (!*optarg || *endptr || timeout < 0)
+			{
 				log_error(srv->errh, __FILE__, __LINE__,
-				  "Invalid idle timeout value: %s", optarg);
+						  "Invalid idle timeout value: %s", optarg);
 				return -1;
 			}
 			idle_limit = (int)timeout;
 			break;
 		}
-		case 'p': print_config = 1; break;
-		case 't': ++test_config; break;
-		case '1': if (0 == oneshot_fd) oneshot_fd = dup(STDIN_FILENO);
-			  break;
-		case 'D': srv->srvconf.dont_daemonize = 1; break;
-		case 'v': show_version(); return 0;
-		case 'V': show_features(); return 0;
-		case 'h': show_help(); return 0;
+		case 'p':
+			print_config = 1;
+			break;
+		case 't':
+			++test_config;
+			break;
+		case '1':
+			if (0 == oneshot_fd)
+				oneshot_fd = dup(STDIN_FILENO);
+			break;
+		case 'D':
+			srv->srvconf.dont_daemonize = 1;
+			break;
+		case 'v':
+			show_version();
+			return 0;
+		case 'V':
+			show_features();
+			return 0;
+		case 'h':
+			show_help();
+			return 0;
 		default:
 			show_help();
 			return -1;
 		}
 	}
 
-      #if defined(__CYGWIN__) || defined(_WIN32)
-	if (!srv->config_data_base && NULL != getenv("NSSM_SERVICE_NAME")) {
+#if defined(__CYGWIN__) || defined(_WIN32)
+	if (!srv->config_data_base && NULL != getenv("NSSM_SERVICE_NAME"))
+	{
 		char *dir = getenv("NSSM_SERVICE_DIR");
-		if (NULL != dir && 0 != chdir(dir)) {
+		if (NULL != dir && 0 != chdir(dir))
+		{
 			log_perror(srv->errh, __FILE__, __LINE__, "chdir %s failed", dir);
 			return -1;
 		}
 		srv->srvconf.dont_daemonize = 1;
 		srv->srvconf.modules_dir = "modules";
-		if (config_read(srv, "conf/lighttpd.conf")) return -1;
+		if (config_read(srv, "conf/lighttpd.conf"))
+			return -1;
 	}
-      #ifndef HAVE_FORK
+#ifndef HAVE_FORK
 	srv->srvconf.dont_daemonize = 1;
-      #endif
-      #endif
+#endif
+#endif
 
-	if (!srv->config_data_base) {
+	if (!srv->config_data_base)
+	{
 		log_error(srv->errh, __FILE__, __LINE__,
-		  "No configuration available. Try using -f option.");
+				  "No configuration available. Try using -f option.");
 		return -1;
 	}
 
 	if (1 == srv->srvconf.max_worker)
 		srv->srvconf.max_worker = 0;
 
-	if (print_config) {
+	if (print_config)
+	{
 		config_print(srv);
 		puts(srv->tmp_buf->ptr);
 	}
 
-	if (test_config) {
+	if (test_config)
+	{
 		srv->srvconf.pid_file = NULL;
-		if (1 == test_config) {
+		if (1 == test_config)
+		{
 			printf("Syntax OK\n");
-		} else { /*(test_config > 1)*/
+		}
+		else
+		{ /*(test_config > 1)*/
 			test_config = 0;
 			srv->srvconf.preflight_check = 1;
 			srv->srvconf.dont_daemonize = 1;
 		}
 	}
 
-	if (test_config || print_config) {
+	if (test_config || print_config)
+	{
 		return 0;
 	}
 
-  #if defined(HAVE_MALLOC_TRIM)
+#if defined(HAVE_MALLOC_TRIM)
 	if (srv->srvconf.max_conns <= 16 && malloc_top_pad == 524288)
 		malloc_top_pad = 131072; /*(reduce memory use on small systems)*/
-  #endif
+#endif
 
-	if (oneshot_fd) {
-		if (oneshot_fd <= STDERR_FILENO) {
+	if (oneshot_fd)
+	{
+		if (oneshot_fd <= STDERR_FILENO)
+		{
 			log_error(srv->errh, __FILE__, __LINE__,
-			  "Invalid fds at startup with lighttpd -1");
+					  "Invalid fds at startup with lighttpd -1");
 			return -1;
 		}
 		graceful_shutdown = 1;
 		srv->sockets_disabled = 2;
 		srv->srvconf.dont_daemonize = 1;
 		srv->srvconf.pid_file = NULL;
-		if (srv->srvconf.max_worker) {
+		if (srv->srvconf.max_worker)
+		{
 			srv->srvconf.max_worker = 0;
 			log_error(srv->errh, __FILE__, __LINE__,
-			  "server one-shot command line option disables server.max-worker config file option.");
+					  "server one-shot command line option disables server.max-worker config file option.");
 		}
 
 		struct stat st;
-		if (0 != fstat(oneshot_fd, &st)) {
+		if (0 != fstat(oneshot_fd, &st))
+		{
 			log_perror(srv->errh, __FILE__, __LINE__, "fstat()");
 			return -1;
 		}
 
-	  #ifndef _WIN32 /*(skip S_ISFIFO() and hope for the best if _WIN32)*/
-		if (S_ISFIFO(st.st_mode)) {
+#ifndef _WIN32 /*(skip S_ISFIFO() and hope for the best if _WIN32)*/
+		if (S_ISFIFO(st.st_mode))
+		{
 			oneshot_fdout = dup(STDOUT_FILENO);
-			if (oneshot_fdout <= STDERR_FILENO) {
+			if (oneshot_fdout <= STDERR_FILENO)
+			{
 				log_perror(srv->errh, __FILE__, __LINE__, "dup()");
 				return -1;
 			}
 		}
-	  #endif
-	  #ifndef _WIN32 /*(skip S_ISSOCK() and hope for the best if _WIN32)*/
-		else if (!S_ISSOCK(st.st_mode)) {
+#endif
+#ifndef _WIN32 /*(skip S_ISSOCK() and hope for the best if _WIN32)*/
+		else if (!S_ISSOCK(st.st_mode))
+		{
 			/* require that fd is a socket
 			 * (modules might expect STDIN_FILENO and STDOUT_FILENO opened to /dev/null) */
 			log_error(srv->errh, __FILE__, __LINE__,
-			  "lighttpd -1 stdin is not a socket");
+					  "lighttpd -1 stdin is not a socket");
 			return -1;
 		}
-	  #endif
+#endif
 	}
 
-	if (srv->srvconf.bindhost && buffer_is_equal_string(srv->srvconf.bindhost, CONST_STR_LEN("/dev/stdin"))) {
+	if (srv->srvconf.bindhost && buffer_is_equal_string(srv->srvconf.bindhost, CONST_STR_LEN("/dev/stdin")))
+	{
 		/* XXX: to potentially support on _WIN32,
 		 *      (SOCKET)GetStdHandle(STD_INPUT_HANDLE) and
 		 *      WSADuplicateSocket() instead of dup() */
 		if (-1 == srv->stdin_fd)
 			srv->stdin_fd = dup(STDIN_FILENO);
-		if (srv->stdin_fd <= STDERR_FILENO) {
+		if (srv->stdin_fd <= STDERR_FILENO)
+		{
 			log_error(srv->errh, __FILE__, __LINE__,
-			  "Invalid fds at startup");
+					  "Invalid fds at startup");
 			return -1;
 		}
 	}
 
 	/* close stdin and stdout, as they are not needed */
-  #ifdef _WIN32
+#ifdef _WIN32
 	/* _WIN32 file descriptors are not allocated lowest first.
 	 * Open NUL in binary mode and as (default) inheritable handle
 	 * https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/dup-dup2?view=msvc-170
@@ -1574,68 +1754,76 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 	 * An open file descriptor has an underlying operating system HANDLE.
 	 * However, standard handles are cached at program startup,
 	 * so we try to match them all back up after redirection. */
-	if (   NULL == freopen("nul:", "rb", stdin)
-	    || NULL == freopen("nul:", "wb", stdout)
-	    || (_fileno(stderr) == -2
-		&& NULL == freopen("nul:", "wb", stderr))) {
+	if (NULL == freopen("nul:", "rb", stdin) || NULL == freopen("nul:", "wb", stdout) || (_fileno(stderr) == -2 && NULL == freopen("nul:", "wb", stderr)))
+	{
 		log_perror(srv->errh, __FILE__, __LINE__, "freopen() NUL");
 		return -1;
 	}
 	SetStdHandle(STD_INPUT_HANDLE, (HANDLE)_get_osfhandle(_fileno(stdin)));
-	SetStdHandle(STD_OUTPUT_HANDLE,(HANDLE)_get_osfhandle(_fileno(stdout)));
+	SetStdHandle(STD_OUTPUT_HANDLE, (HANDLE)_get_osfhandle(_fileno(stdout)));
 	SetStdHandle(STD_ERROR_HANDLE, (HANDLE)_get_osfhandle(_fileno(stderr)));
 	fdevent_setfd_cloexec(STDERR_FILENO);
-  #else
+#else
 	{
 		struct stat st;
 		int devnull;
 		int errfd;
-		do {
+		do
+		{
 			/* coverity[overwrite_var : FALSE] */
 			devnull = fdevent_open_devnull();
-		      #ifdef __COVERITY__
+#ifdef __COVERITY__
 			__coverity_escape__(devnull);
-		      #endif
+#endif
 		} while (-1 != devnull && devnull <= STDERR_FILENO);
-		if (-1 == devnull) {
+		if (-1 == devnull)
+		{
 			log_perror(srv->errh, __FILE__, __LINE__,
-			  "opening /dev/null failed");
+					   "opening /dev/null failed");
 			return -1;
 		}
 		errfd = (0 == fstat(STDERR_FILENO, &st)) ? -1 : devnull;
-		if (0 != fdevent_set_stdin_stdout_stderr(devnull, devnull, errfd)) {
+		if (0 != fdevent_set_stdin_stdout_stderr(devnull, devnull, errfd))
+		{
 			log_perror(srv->errh, __FILE__, __LINE__,
-			  "setting default fds failed");
-		      #ifdef FD_CLOEXEC
-			if (-1 != errfd) close(errfd);
-			if (devnull != errfd) close(devnull);
-		      #endif
+					   "setting default fds failed");
+#ifdef FD_CLOEXEC
+			if (-1 != errfd)
+				close(errfd);
+			if (devnull != errfd)
+				close(devnull);
+#endif
 			return -1;
 		}
-	      #ifdef FD_CLOEXEC
-		if (-1 != errfd) close(errfd);
-		if (devnull != errfd) close(devnull);
-	      #endif
+#ifdef FD_CLOEXEC
+		if (-1 != errfd)
+			close(errfd);
+		if (devnull != errfd)
+			close(devnull);
+#endif
 	}
-  #endif
+#endif
 
 	http_range_config_allow_http10(config_feature_bool(srv, "http10.range", 0));
 
-	if (0 != config_set_defaults(srv)) {
+	if (0 != config_set_defaults(srv))
+	{
 		log_error(srv->errh, __FILE__, __LINE__,
-		  "setting default values failed");
+				  "setting default values failed");
 		return -1;
 	}
 
-	if (plugins_load(srv)) {
+	if (plugins_load(srv))
+	{
 		log_error(srv->errh, __FILE__, __LINE__,
-		  "loading plugins finally failed");
+				  "loading plugins finally failed");
 		return -1;
 	}
 
-	if (HANDLER_GO_ON != plugins_call_init(srv)) {
+	if (HANDLER_GO_ON != plugins_call_init(srv))
+	{
 		log_error(srv->errh, __FILE__, __LINE__,
-		  "Initialization of plugins failed. Going down.");
+				  "Initialization of plugins failed. Going down.");
 		return -1;
 	}
 
@@ -1647,7 +1835,8 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 	if (config_feature_bool(srv, "server.h1-discard-backend-1xx", 0))
 		http_dispatch[HTTP_VERSION_1_1].send_1xx = 0;
 
-	if (config_feature_bool(srv, "server.discard-backend-1xx", 0)) {
+	if (config_feature_bool(srv, "server.discard-backend-1xx", 0))
+	{
 		http_dispatch[HTTP_VERSION_3].send_1xx = 0;
 		http_dispatch[HTTP_VERSION_2].send_1xx = 0;
 		http_dispatch[HTTP_VERSION_1_1].send_1xx = 0;
@@ -1655,45 +1844,56 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 
 	/* mod_indexfile should be listed in server.modules prior to dynamic handlers */
 	uint32_t i = 0;
-	for (const char *pname = NULL; i < srv->plugins.used; ++i) {
+	for (const char *pname = NULL; i < srv->plugins.used; ++i)
+	{
 		plugin *p = ((plugin **)srv->plugins.ptr)[i];
-		if (0 == strcmp(p->name, "indexfile")) {
+		if (0 == strcmp(p->name, "indexfile"))
+		{
 			if (pname)
 				log_error(srv->errh, __FILE__, __LINE__,
-				  "Warning: mod_indexfile should be listed in server.modules prior to mod_%s", pname);
+						  "Warning: mod_indexfile should be listed in server.modules prior to mod_%s", pname);
 			break;
 		}
-		if (p->handle_subrequest_start && p->handle_subrequest) {
-			if (!pname) pname = p->name;
+		if (p->handle_subrequest_start && p->handle_subrequest)
+		{
+			if (!pname)
+				pname = p->name;
 		}
 	}
 
 	/* open pid file BEFORE chroot */
-	if (-2 == pid_fd) pid_fd = -1; /*(initial startup state)*/
-	if (-1 == pid_fd && srv->srvconf.pid_file) {
+	if (-2 == pid_fd)
+		pid_fd = -1; /*(initial startup state)*/
+	if (-1 == pid_fd && srv->srvconf.pid_file)
+	{
 		const char *pidfile = srv->srvconf.pid_file->ptr;
-		if (-1 == (pid_fd = fdevent_open_cloexec(pidfile, 0, O_WRONLY | O_CREAT | O_EXCL | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))) {
+		if (-1 == (pid_fd = fdevent_open_cloexec(pidfile, 0, O_WRONLY | O_CREAT | O_EXCL | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))
+		{
 			struct stat st;
-			if (errno != EEXIST) {
+			if (errno != EEXIST)
+			{
 				log_perror(srv->errh, __FILE__, __LINE__,
-				  "opening pid-file failed: %s", pidfile);
+						   "opening pid-file failed: %s", pidfile);
 				return -1;
 			}
 
-			if (0 != stat(pidfile, &st)) {
+			if (0 != stat(pidfile, &st))
+			{
 				log_perror(srv->errh, __FILE__, __LINE__,
-				  "stating existing pid-file failed: %s", pidfile);
+						   "stating existing pid-file failed: %s", pidfile);
 			}
 
-			if (!S_ISREG(st.st_mode)) {
+			if (!S_ISREG(st.st_mode))
+			{
 				log_error(srv->errh, __FILE__, __LINE__,
-				  "pid-file exists and isn't regular file: %s", pidfile);
+						  "pid-file exists and isn't regular file: %s", pidfile);
 				return -1;
 			}
 
-			if (-1 == (pid_fd = fdevent_open_cloexec(pidfile, 0, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))) {
+			if (-1 == (pid_fd = fdevent_open_cloexec(pidfile, 0, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))
+			{
 				log_perror(srv->errh, __FILE__, __LINE__,
-				  "opening pid-file failed: %s", pidfile);
+						   "opening pid-file failed: %s", pidfile);
 				return -1;
 			}
 		}
@@ -1701,13 +1901,15 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 
 	{
 #ifdef HAVE_GETRLIMIT
-		struct rlimit rlim = { 4096, 4096 };
+		struct rlimit rlim = {4096, 4096};
 		int use_rlimit = 1;
 #ifdef HAVE_VALGRIND_VALGRIND_H
-		if (RUNNING_ON_VALGRIND) use_rlimit = 0;
+		if (RUNNING_ON_VALGRIND)
+			use_rlimit = 0;
 #endif
 
-		if (0 != getrlimit(RLIMIT_NOFILE, &rlim)) {
+		if (0 != getrlimit(RLIMIT_NOFILE, &rlim))
+		{
 			log_perror(srv->errh, __FILE__, __LINE__, "getrlimit()");
 			use_rlimit = 0;
 		}
@@ -1715,15 +1917,17 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 		/**
 		 * if we are not root can can't increase the fd-limit above rlim_max, but we can reduce it
 		 */
-		if (use_rlimit && srv->srvconf.max_fds
-		    && (i_am_root || srv->srvconf.max_fds <= rlim.rlim_max)) {
+		if (use_rlimit && srv->srvconf.max_fds && (i_am_root || srv->srvconf.max_fds <= rlim.rlim_max))
+		{
 			/* set rlimits */
 
 			rlim_t rlim_cur = rlim.rlim_cur;
 			rlim.rlim_cur = srv->srvconf.max_fds;
-			if (i_am_root) rlim.rlim_max = srv->srvconf.max_fds;
+			if (i_am_root)
+				rlim.rlim_max = srv->srvconf.max_fds;
 
-			if (0 != setrlimit(RLIMIT_NOFILE, &rlim)) {
+			if (0 != setrlimit(RLIMIT_NOFILE, &rlim))
+			{
 				log_perror(srv->errh, __FILE__, __LINE__, "setrlimit()");
 				log_error(srv->errh, __FILE__, __LINE__, "setrlimit() may need root to run once: setsebool -P httpd_setrlimit on");
 				use_rlimit = 0;
@@ -1735,98 +1939,116 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 		/*(default upper limit of 4k if server.max-fds not specified)*/
 		if (0 == srv->srvconf.max_fds)
 			srv->srvconf.max_fds = (rlim.rlim_cur <= 4096)
-			  ? (unsigned short)rlim.rlim_cur
-			  : 4096;
+									   ? (unsigned short)rlim.rlim_cur
+									   : 4096;
 
 		/* set core file rlimit, if enable_cores is set */
-		if (use_rlimit && srv->srvconf.enable_cores && getrlimit(RLIMIT_CORE, &rlim) == 0) {
+		if (use_rlimit && srv->srvconf.enable_cores && getrlimit(RLIMIT_CORE, &rlim) == 0)
+		{
 			rlim.rlim_cur = rlim.rlim_max;
 			setrlimit(RLIMIT_CORE, &rlim);
 		}
 #else
-	  #ifdef _WIN32
+#ifdef _WIN32
 		/*(default upper limit of 4k if server.max-fds not specified)*/
 		if (0 == srv->srvconf.max_fds)
 			srv->srvconf.max_fds = 4096;
-	  #endif
+#endif
 #endif
 	}
 
 	/* we need root-perms for port < 1024 */
-	if (0 != network_init(srv, srv->stdin_fd)) {
+	if (0 != network_init(srv, srv->stdin_fd))
+	{
 		return -1;
 	}
 	srv->stdin_fd = -1;
 
-	if (i_am_root) {
+	if (i_am_root)
+	{
 #ifdef HAVE_PWD_H
 		/* set user and group */
 		struct group *grp = NULL;
 		struct passwd *pwd = NULL;
 
-		if (srv->srvconf.groupname) {
-			if (NULL == (grp = getgrnam(srv->srvconf.groupname->ptr))) {
+		if (srv->srvconf.groupname)
+		{
+			if (NULL == (grp = getgrnam(srv->srvconf.groupname->ptr)))
+			{
 				log_error(srv->errh, __FILE__, __LINE__,
-				  "can't find groupname %s", srv->srvconf.groupname->ptr);
+						  "can't find groupname %s", srv->srvconf.groupname->ptr);
 				return -1;
 			}
 		}
 
-		if (srv->srvconf.username) {
-			if (NULL == (pwd = getpwnam(srv->srvconf.username->ptr))) {
+		if (srv->srvconf.username)
+		{
+			if (NULL == (pwd = getpwnam(srv->srvconf.username->ptr)))
+			{
 				log_error(srv->errh, __FILE__, __LINE__,
-				  "can't find username %s", srv->srvconf.username->ptr);
+						  "can't find username %s", srv->srvconf.username->ptr);
 				return -1;
 			}
 
-			if (pwd->pw_uid == 0) {
+			if (pwd->pw_uid == 0)
+			{
 				log_error(srv->errh, __FILE__, __LINE__,
-				  "I will not set uid to 0.  Perhaps you should comment out server.username in lighttpd.conf\n");
+						  "I will not set uid to 0.  Perhaps you should comment out server.username in lighttpd.conf\n");
 				return -1;
 			}
 
-			if (NULL == grp && NULL == (grp = getgrgid(pwd->pw_gid))) {
+			if (NULL == grp && NULL == (grp = getgrgid(pwd->pw_gid)))
+			{
 				log_error(srv->errh, __FILE__, __LINE__,
-				  "can't find group id %d", (int)pwd->pw_gid);
+						  "can't find group id %d", (int)pwd->pw_gid);
 				return -1;
 			}
 		}
 
-		if (NULL != grp) {
-			if (grp->gr_gid == 0) {
+		if (NULL != grp)
+		{
+			if (grp->gr_gid == 0)
+			{
 				log_error(srv->errh, __FILE__, __LINE__,
-				  "I will not set gid to 0.  Perhaps you should comment out server.groupname in lighttpd.conf\n");
+						  "I will not set gid to 0.  Perhaps you should comment out server.groupname in lighttpd.conf\n");
 				return -1;
 			}
 		}
 
-		/* 
+		/*
 		 * Change group before chroot, when we have access
 		 * to /etc/group
 		 * */
-		if (NULL != grp) {
-			if (-1 == setgid(grp->gr_gid)) {
+		if (NULL != grp)
+		{
+			if (-1 == setgid(grp->gr_gid))
+			{
 				log_perror(srv->errh, __FILE__, __LINE__, "setgid()");
 				return -1;
 			}
-			if (-1 == setgroups(0, NULL)) {
+			if (-1 == setgroups(0, NULL))
+			{
 				log_perror(srv->errh, __FILE__, __LINE__, "setgroups()");
 				return -1;
 			}
-			if (srv->srvconf.username) {
+			if (srv->srvconf.username)
+			{
 				initgroups(srv->srvconf.username->ptr, grp->gr_gid);
 			}
 		}
 #endif
 #ifdef HAVE_CHROOT
-		if (srv->srvconf.changeroot) {
+		if (srv->srvconf.changeroot)
+		{
 			tzset();
 
-			if (-1 == chroot(srv->srvconf.changeroot->ptr)) {
+			if (-1 == chroot(srv->srvconf.changeroot->ptr))
+			{
 				log_perror(srv->errh, __FILE__, __LINE__, "chroot()");
 				return -1;
 			}
-			if (-1 == chdir("/")) {
+			if (-1 == chdir("/"))
+			{
 				log_perror(srv->errh, __FILE__, __LINE__, "chdir()");
 				return -1;
 			}
@@ -1834,8 +2056,10 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 #endif
 #ifdef HAVE_PWD_H
 		/* drop root privs */
-		if (NULL != pwd) {
-			if (-1 == setuid(pwd->pw_uid)) {
+		if (NULL != pwd)
+		{
+			if (-1 == setuid(pwd->pw_uid))
+			{
 				log_perror(srv->errh, __FILE__, __LINE__, "setuid()");
 				return -1;
 			}
@@ -1845,12 +2069,14 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 		/**
 		 * on IRIX 6.5.30 they have prctl() but no DUMPABLE
 		 */
-		if (srv->srvconf.enable_cores) {
+		if (srv->srvconf.enable_cores)
+		{
 			prctl(PR_SET_DUMPABLE, 1, 0, 0, 0);
 		}
 #elif defined(HAVE_SYS_PROCCTL_H) && defined(PROC_TRACE_CTL_ENABLE)
 		/* (DragonFlyBSD has procctl(), but not PROC_TRACE_CTL_ENABLE) */
-		if (srv->srvconf.enable_cores) {
+		if (srv->srvconf.enable_cores)
+		{
 			int dumpable = PROC_TRACE_CTL_ENABLE;
 			procctl(P_PID, 0, PROC_TRACE_CTL, &dumpable);
 		}
@@ -1859,7 +2085,8 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 		 * setpflags seems uniquely a solaris/illumos feature
 		 * but just taking extra precautions clearing __PROC_PROTECT option
 		 */
-		if (srv->srvconf.enable_cores) {
+		if (srv->srvconf.enable_cores)
+		{
 			setpflags(__PROC_PROTECT, 0);
 		}
 #endif
@@ -1867,41 +2094,49 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 
 #ifdef HAVE_FORK
 	/* network is up, let's daemonize ourself */
-	if (0 == srv->srvconf.dont_daemonize && 0 == graceful_restart) {
+	if (0 == srv->srvconf.dont_daemonize && 0 == graceful_restart)
+	{
 		parent_pipe_fd = daemonize();
 	}
 #endif
-	graceful_restart = 0;/*(reset here after avoiding further daemonizing)*/
-	if (0 == oneshot_fd) graceful_shutdown = 0;
+	graceful_restart = 0; /*(reset here after avoiding further daemonizing)*/
+	if (0 == oneshot_fd)
+		graceful_shutdown = 0;
 
 	server_main_setup_signals();
 
-  #ifdef HAVE_GETUID
+#ifdef HAVE_GETUID
 	srv->gid = getgid();
 	srv->uid = getuid();
-  #endif
+#endif
 	srv->pid = getpid();
 
 	/* write pid file */
-	if (pid_fd > 2) {
-		buffer * const tb = srv->tmp_buf;
+	if (pid_fd > 2)
+	{
+		buffer *const tb = srv->tmp_buf;
 		buffer_clear(tb);
 		buffer_append_int(tb, srv->pid);
 		buffer_append_char(tb, '\n');
-		if (-1 == write_all(pid_fd, BUF_PTR_LEN(tb))) {
+		if (-1 == write_all(pid_fd, BUF_PTR_LEN(tb)))
+		{
 			log_perror(srv->errh, __FILE__, __LINE__, "Couldn't write pid file");
 			close(pid_fd);
 			pid_fd = -1;
 			return -1;
 		}
-	} else if (pid_fd < -2) {
+	}
+	else if (pid_fd < -2)
+	{
 		pid_fd = -pid_fd;
 	}
 
 	/* Close stderr ASAP in the child process to make sure that nothing
 	 * is being written to that fd which may not be valid anymore. */
-	if (!srv->srvconf.preflight_check) {
-		if (-1 == config_log_error_open(srv)) {
+	if (!srv->srvconf.preflight_check)
+	{
+		if (-1 == config_log_error_open(srv))
+		{
 			log_error(srv->errh, __FILE__, __LINE__, "Opening errorlog failed. Going down.");
 			return -1;
 		}
@@ -1909,39 +2144,45 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 			log_error(srv->errh, __FILE__, __LINE__, "server started (" PACKAGE_DESC ")");
 	}
 
-	if (HANDLER_GO_ON != plugins_call_set_defaults(srv)) {
+	if (HANDLER_GO_ON != plugins_call_set_defaults(srv))
+	{
 		log_error(srv->errh, __FILE__, __LINE__, "Configuration of plugins failed. Going down.");
 		return -1;
 	}
 
-	if (!config_finalize(srv, &default_server_tag)) {
+	if (!config_finalize(srv, &default_server_tag))
+	{
 		return -1;
 	}
 
-	if (srv->srvconf.preflight_check) {
-		/*printf("Preflight OK");*//*(stdout reopened to /dev/null)*/
+	if (srv->srvconf.preflight_check)
+	{
+		/*printf("Preflight OK");*/ /*(stdout reopened to /dev/null)*/
 		return 0;
 	}
 
-
 #ifdef HAVE_FORK
 	/**
 	 * notify daemonize-grandparent of successful startup
 	 * do this before any further forking is done (workers)
 	 */
-	if (0 == srv->srvconf.dont_daemonize && -1 != parent_pipe_fd) {
-		if (0 > write(parent_pipe_fd, "", 1)) return -1;
+	if (0 == srv->srvconf.dont_daemonize && -1 != parent_pipe_fd)
+	{
+		if (0 > write(parent_pipe_fd, "", 1))
+			return -1;
 		close(parent_pipe_fd);
 	}
 
-	if (idle_limit && srv->srvconf.max_worker) {
+	if (idle_limit && srv->srvconf.max_worker)
+	{
 		srv->srvconf.max_worker = 0;
 		log_error(srv->errh, __FILE__, __LINE__,
-		  "server idle time limit command line option disables server.max-worker config file option.");
+				  "server idle time limit command line option disables server.max-worker config file option.");
 	}
 
 	/* start watcher and workers */
-	if (srv->srvconf.max_worker > 0) {
+	if (srv->srvconf.max_worker > 0)
+	{
 		int rc = server_main_setup_workers(srv, srv->srvconf.max_worker);
 		if (rc != 1) /* 1 for worker; 0 for worker parent done; -1 for error */
 			return rc;
@@ -1949,10 +2190,11 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 #endif
 
 	srv->max_fds = (int)srv->srvconf.max_fds;
-        if (srv->max_fds < 32) /*(sanity check; not expected)*/
-            srv->max_fds = 32; /*(server load checks will fail if too low)*/
+	if (srv->max_fds < 32) /*(sanity check; not expected)*/
+		srv->max_fds = 32; /*(server load checks will fail if too low)*/
 	srv->ev = fdevent_init(srv->srvconf.event_handler, &srv->max_fds, &srv->cur_fds, srv->errh);
-	if (NULL == srv->ev) {
+	if (NULL == srv->ev)
+	{
 		log_error(srv->errh, __FILE__, __LINE__, "fdevent_init failed");
 		return -1;
 	}
@@ -1961,18 +2203,23 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 	srv->max_fds_hiwat = srv->max_fds * 9 / 10;
 
 	/* set max-conns */
-	if (srv->srvconf.max_conns > srv->max_fds/2) {
+	if (srv->srvconf.max_conns > srv->max_fds / 2)
+	{
 		/* we can't have more connections than max-fds/2 */
 		log_error(srv->errh, __FILE__, __LINE__,
-		  "can't have more connections than fds/2: %hu %d",
-		  srv->srvconf.max_conns, srv->max_fds);
-		srv->lim_conns = srv->srvconf.max_conns = srv->max_fds/2;
-	} else if (srv->srvconf.max_conns) {
+				  "can't have more connections than fds/2: %hu %d",
+				  srv->srvconf.max_conns, srv->max_fds);
+		srv->lim_conns = srv->srvconf.max_conns = srv->max_fds / 2;
+	}
+	else if (srv->srvconf.max_conns)
+	{
 		/* otherwise respect the wishes of the user */
 		srv->lim_conns = srv->srvconf.max_conns;
-	} else {
+	}
+	else
+	{
 		/* or use the default: we really don't want to hit max-fds */
-		srv->lim_conns = srv->srvconf.max_conns = srv->max_fds/3;
+		srv->lim_conns = srv->srvconf.max_conns = srv->max_fds / 3;
 	}
 
 	/*
@@ -1980,16 +2227,18 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 	 * all server sockets get their handlers
 	 *
 	 * */
-	if (0 != network_register_fdevents(srv)) {
+	if (0 != network_register_fdevents(srv))
+	{
 		return -1;
 	}
 
 	chunkqueue_internal_pipes(config_feature_bool(srv, "chunkqueue.splice", 1));
 
 	/* might fail if user is using fam (not gamin) and famd isn't running */
-	if (!stat_cache_init(srv->ev, srv->errh)) {
+	if (!stat_cache_init(srv->ev, srv->errh))
+	{
 		log_error(srv->errh, __FILE__, __LINE__,
-		  "stat-cache could not be setup, dying.");
+				  "stat-cache could not be setup, dying.");
 		return -1;
 	}
 
@@ -2001,7 +2250,8 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 		interval.it_interval.tv_usec = 0;
 		interval.it_value.tv_sec = 1;
 		interval.it_value.tv_usec = 0;
-		if (setitimer(ITIMER_REAL, &interval, NULL)) {
+		if (setitimer(ITIMER_REAL, &interval, NULL))
+		{
 			log_perror(srv->errh, __FILE__, __LINE__, "setitimer()");
 			return -1;
 		}
@@ -2009,19 +2259,21 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 #endif
 
 	/* get the current number of FDs */
-  #ifdef _WIN32
+#ifdef _WIN32
 	srv->cur_fds = 3; /*(estimate on _WIN32)*/
-  #else
+#else
 	{
 		int fd = fdevent_open_devnull();
-		if (fd >= 0) {
+		if (fd >= 0)
+		{
 			srv->cur_fds = fd;
 			close(fd);
 		}
 	}
-  #endif
+#endif
 
-	if (0 != server_sockets_set_nb_cloexec(srv)) {
+	if (0 != server_sockets_set_nb_cloexec(srv))
+	{
 		return -1;
 	}
 
@@ -2029,13 +2281,16 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 	if (HANDLER_GO_ON != plugins_call_worker_init(srv))
 		return -1;
 
-	if (oneshot_fdout > 0) {
-		if (server_oneshot_init_pipe(srv, oneshot_fd, oneshot_fdout)) {
+	if (oneshot_fdout > 0)
+	{
+		if (server_oneshot_init_pipe(srv, oneshot_fd, oneshot_fdout))
+		{
 			oneshot_fd = -1;
 			oneshot_fdout = -1;
 		}
 	}
-	else if (oneshot_fd && server_oneshot_init(srv, oneshot_fd)) {
+	else if (oneshot_fd && server_oneshot_init(srv, oneshot_fd))
+	{
 		oneshot_fd = -1;
 	}
 
@@ -2046,297 +2301,352 @@ static int server_main_setup (server * const srv, int argc, char **argv) {
 }
 
 __attribute_cold__
-__attribute_noinline__
-static void server_handle_sighup (server * const srv) {
+	__attribute_noinline__ static void
+	server_handle_sighup(server *const srv)
+{
 
-			/* cycle logfiles */
+	/* cycle logfiles */
 
-			plugins_call_handle_sighup(srv);
-			fdlog_files_cycle(srv->errh); /* reopen log files, not pipes */
+	plugins_call_handle_sighup(srv);
+	fdlog_files_cycle(srv->errh); /* reopen log files, not pipes */
 #ifdef HAVE_SIGACTION
-				log_error(srv->errh, __FILE__, __LINE__,
-				  "logfiles cycled UID = %d PID = %d",
-				  (int)last_sighup_info.si_uid,
-				  (int)last_sighup_info.si_pid);
+	log_error(srv->errh, __FILE__, __LINE__,
+			  "logfiles cycled UID = %d PID = %d",
+			  (int)last_sighup_info.si_uid,
+			  (int)last_sighup_info.si_pid);
 #else
-				log_error(srv->errh, __FILE__, __LINE__,
-				  "logfiles cycled");
+	log_error(srv->errh, __FILE__, __LINE__,
+			  "logfiles cycled");
 #endif
 }
 
-__attribute_noinline__
-static void server_handle_sigalrm (server * const srv, unix_time64_t mono_ts, unix_time64_t last_active_ts) {
+__attribute_noinline__ static void server_handle_sigalrm(server *const srv, unix_time64_t mono_ts, unix_time64_t last_active_ts)
+{
 
-				plugins_call_handle_trigger(srv);
+	plugins_call_handle_trigger(srv);
 
-				log_monotonic_secs = mono_ts;
-				log_epoch_secs = server_epoch_secs(srv, 0);
+	log_monotonic_secs = mono_ts;
+	log_epoch_secs = server_epoch_secs(srv, 0);
 
-				/* check idle time limit, if enabled */
-				if (idle_limit && idle_limit < mono_ts - last_active_ts && !graceful_shutdown) {
-					log_error(srv->errh, __FILE__, __LINE__,
-					  "[note] idle timeout %ds exceeded, "
-					  "initiating graceful shutdown", (int)idle_limit);
-					graceful_shutdown = 2; /* value 2 indicates idle timeout */
-					if (graceful_restart) {
-						graceful_restart = 0;
-						if (pid_fd < -2) pid_fd = -pid_fd;
-						server_sockets_close(srv);
-					}
-				}
+	/* check idle time limit, if enabled */
+	if (idle_limit && idle_limit < mono_ts - last_active_ts && !graceful_shutdown)
+	{
+		log_error(srv->errh, __FILE__, __LINE__,
+				  "[note] idle timeout %ds exceeded, "
+				  "initiating graceful shutdown",
+				  (int)idle_limit);
+		graceful_shutdown = 2; /* value 2 indicates idle timeout */
+		if (graceful_restart)
+		{
+			graceful_restart = 0;
+			if (pid_fd < -2)
+				pid_fd = -pid_fd;
+			server_sockets_close(srv);
+		}
+	}
 
-			      #ifdef HAVE_GETLOADAVG
-				/* refresh loadavg data every 30 seconds */
-				if (srv->loadts + 30 < mono_ts) {
-					if (-1 != getloadavg(srv->loadavg, 3)) {
-						srv->loadts = mono_ts;
-					}
-				}
-			      #endif
-
-				if (0 == (mono_ts & 0x3f)) { /*(once every 64 secs)*/
-					/* free logger buffers every 64 secs */
-					fdlog_flushall(srv->errh);
-					/* free excess chunkqueue buffers every 64 secs */
-					chunkqueue_chunk_pool_clear();
-					/* clear request and connection pools every 64 secs */
-					request_pool_free();
-					connections_pool_clear(srv);
-				  #if defined(HAVE_MALLOC_TRIM)
-					if (malloc_trim_fn) malloc_trim_fn(malloc_top_pad);
-				  #endif
-					/* attempt to restart dead piped loggers every 64 secs */
-					if (0 == srv->srvconf.max_worker)
-						fdlog_pipes_restart(mono_ts);
-				}
-				/* cleanup stat-cache */
-				stat_cache_trigger_cleanup();
-				/* reset global/aggregate rate limit counters */
-				config_reset_config_bytes_sec(srv->config_data_base);
-				/* if graceful_shutdown, accelerate cleanup of recently completed request/responses */
-				if (graceful_shutdown && !srv_shutdown)
-					server_graceful_shutdown_maint(srv);
-				connection_periodic_maint(srv, mono_ts);
+#ifdef HAVE_GETLOADAVG
+	/* refresh loadavg data every 30 seconds */
+	if (srv->loadts + 30 < mono_ts)
+	{
+		if (-1 != getloadavg(srv->loadavg, 3))
+		{
+			srv->loadts = mono_ts;
+		}
+	}
+#endif
+
+	if (0 == (mono_ts & 0x3f))
+	{ /*(once every 64 secs)*/
+		/* free logger buffers every 64 secs */
+		fdlog_flushall(srv->errh);
+		/* free excess chunkqueue buffers every 64 secs */
+		chunkqueue_chunk_pool_clear();
+		/* clear request and connection pools every 64 secs */
+		request_pool_free();
+		connections_pool_clear(srv);
+#if defined(HAVE_MALLOC_TRIM)
+		if (malloc_trim_fn)
+			malloc_trim_fn(malloc_top_pad);
+#endif
+		/* attempt to restart dead piped loggers every 64 secs */
+		if (0 == srv->srvconf.max_worker)
+			fdlog_pipes_restart(mono_ts);
+	}
+	/* cleanup stat-cache */
+	stat_cache_trigger_cleanup();
+	/* reset global/aggregate rate limit counters */
+	config_reset_config_bytes_sec(srv->config_data_base);
+	/* if graceful_shutdown, accelerate cleanup of recently completed request/responses */
+	if (graceful_shutdown && !srv_shutdown)
+		server_graceful_shutdown_maint(srv);
+	connection_periodic_maint(srv, mono_ts);
 }
 
-__attribute_noinline__
-static void server_handle_sigchld (server * const srv) {
-			pid_t pid;
-			do {
-				int status;
-				pid = fdevent_waitpid(-1, &status, 1);
-				if (pid > 0) {
-					if (plugins_call_handle_waitpid(srv, pid, status) != HANDLER_GO_ON) {
-						continue;
-					}
-					if (0 == srv->srvconf.max_worker) {
-						/* check piped-loggers and restart, even if shutting down */
-						if (fdlog_pipes_waitpid_cb(pid)) {
-							continue;
-						}
-					}
+__attribute_noinline__ static void server_handle_sigchld(server *const srv)
+{
+	pid_t pid;
+	do
+	{
+		int status;
+		pid = fdevent_waitpid(-1, &status, 1);
+		if (pid > 0)
+		{
+			if (plugins_call_handle_waitpid(srv, pid, status) != HANDLER_GO_ON)
+			{
+				continue;
+			}
+			if (0 == srv->srvconf.max_worker)
+			{
+				/* check piped-loggers and restart, even if shutting down */
+				if (fdlog_pipes_waitpid_cb(pid))
+				{
+					continue;
 				}
-			} while (pid > 0 || (-1 == pid && errno == EINTR));
+			}
+		}
+	} while (pid > 0 || (-1 == pid && errno == EINTR));
 }
 
 __attribute_hot__
-__attribute_nonnull__()
-static void server_run_con_queue (connection * const restrict joblist, const connection * const sentinel) {
-    for (connection *con = joblist, *jqnext; con != sentinel; con = jqnext) {
-        jqnext = con->jqnext;
-        con->jqnext = NULL;
-        connection_state_machine(con);
-    }
+__attribute_nonnull__() static void server_run_con_queue(connection *const restrict joblist, const connection *const sentinel)
+{
+	for (connection *con = joblist, *jqnext; con != sentinel; con = jqnext)
+	{
+		jqnext = con->jqnext;
+		con->jqnext = NULL;
+		connection_state_machine(con);
+	}
 }
 
 __attribute_hot__
-__attribute_noinline__
-static void server_main_loop (server * const srv) {
+	__attribute_noinline__ static void
+	server_main_loop(server *const srv)
+{
 	unix_time64_t last_active_ts = server_monotonic_secs();
 	log_epoch_secs = server_epoch_secs(srv, 0);
 
-	while (!srv_shutdown) {
+	fdevent_poll(srv->ev, -1); // Wait for a connection
+	while (!srv_shutdown)
+	{
 
-		if (handle_sig_hup) {
+		if (handle_sig_hup)
+		{
 			handle_sig_hup = 0;
 			server_handle_sighup(srv);
 		}
 
 		/*(USE_ALARM not used; fdevent_poll() is effective periodic timer)*/
-	      #ifdef USE_ALARM
-		if (handle_sig_alarm) {
+#ifdef USE_ALARM
+		if (handle_sig_alarm)
+		{
 			handle_sig_alarm = 0;
-	      #endif
+#endif
 			unix_time64_t mono_ts = server_monotonic_secs();
-			if (mono_ts != log_monotonic_secs) {
+			if (mono_ts != log_monotonic_secs)
+			{
 				server_handle_sigalrm(srv, mono_ts, last_active_ts);
 			}
-	      #ifdef USE_ALARM
+#ifdef USE_ALARM
 		}
-	      #endif
+#endif
 
-		if (handle_sig_child) {
+		if (handle_sig_child)
+		{
 			handle_sig_child = 0;
 			server_handle_sigchld(srv);
 		}
 
-		if (graceful_shutdown) {
+		if (graceful_shutdown)
+		{
 			server_graceful_state(srv);
-			if (NULL == srv->conns && graceful_shutdown) {
+			if (NULL == srv->conns && graceful_shutdown)
+			{
 				/* we are in graceful shutdown phase and all connections are closed
 				 * we are ready to terminate without harming anyone */
 				srv_shutdown = 1;
 				break;
 			}
-		} else if (srv->sockets_disabled) {
+		}
+		else if (srv->sockets_disabled)
+		{
 			server_overload_check(srv);
-		} else {
+		}
+		else
+		{
 			server_load_check(srv);
 		}
 
-	  #ifndef _MSC_VER
+#ifndef _MSC_VER
 		static
-	  #endif
-		connection * const sentinel =
-		  (connection *)(uintptr_t)&log_con_jqueue;
-		connection * const joblist = log_con_jqueue;
-		log_con_jqueue = sentinel;
-		server_run_con_queue(joblist, sentinel);
+#endif
+			// LEO
+			// 	int counter = 1000;
+			// while (counter-- > 0)
+			while (__AFL_LOOP(1000))
+		{
+			// Force to receive a request -> actually, it's reading a line...
+			fdevent_poll(srv->ev, -1);
+			connection *const sentinel =
+				(connection *)(uintptr_t)&log_con_jqueue;
+			connection *const joblist = log_con_jqueue;
+			log_con_jqueue = sentinel;
+			server_run_con_queue(joblist, sentinel);
+		}
+		srv_shutdown = 1;
 
-		if (fdevent_poll(srv->ev, log_con_jqueue != sentinel ? 0 : 1000) > 0)
-			last_active_ts = log_monotonic_secs;
+		/*if (fdevent_poll(srv->ev, log_con_jqueue != sentinel ? 0 : 1000) > 0)
+			last_active_ts = log_monotonic_secs;*/
 	}
 }
 
 __attribute_cold__
-__attribute_noinline__
-static int main_init_once (void) {
-  #ifdef HAVE_GETUID
-  #ifndef HAVE_ISSETUGID
-  #define issetugid() (geteuid() != getuid() || getegid() != getgid())
-  #endif
-    if (0 != getuid() && issetugid()) { /*check as early as possible in main()*/
-        fprintf(stderr,
-                "Are you nuts ? Don't apply a SUID bit to this binary\n");
-        return 0;
-    }
-  #endif
-
-  #if defined(HAVE_MALLOPT) && defined(M_ARENA_MAX)
-  #ifdef LIGHTTPD_STATIC
-    mallopt(M_ARENA_MAX, 2); /*(ignore error, if any)*/
-  #else
-    {
-        int (*mallopt_fn)(int, int);
-        mallopt_fn = (int (*)(int, int))(intptr_t)dlsym(RTLD_DEFAULT,"mallopt");
-        if (mallopt_fn) mallopt_fn(M_ARENA_MAX, 2); /*(ignore error, if any)*/
-    }
-  #endif
-  #endif
-
-  #if defined(HAVE_MALLOC_TRIM)
-    malloc_top_pad = 524288;
-    {
-        const char * const top_pad_str = getenv("MALLOC_TOP_PAD_");
-        if (top_pad_str) {
-            unsigned long top_pad = strtoul(top_pad_str, NULL, 10);
-            if (top_pad != ULONG_MAX) malloc_top_pad = (size_t)top_pad;
-        }
-    }
-  #ifdef LIGHTTPD_STATIC
-    malloc_trim_fn = malloc_trim;
-  #else
-    malloc_trim_fn =
-      (int (*)(size_t))(intptr_t)dlsym(RTLD_DEFAULT,"malloc_trim");
-  #endif
-  #endif
-
-    /* for nice %b handling in strftime() */
-  #ifdef _WIN32
-    setlocale(LC_ALL, "C.UTF-8");
-   #ifdef __MINGW32__
-    _setmbcp(_MB_CP_LOCALE);
-   #else
-    _setmbcp(_MB_CP_UTF8);
-   #endif
-  #else
-    setlocale(LC_TIME, "C");
-  #endif
-    tzset();
-
-    return 1;
+	__attribute_noinline__ static int
+	main_init_once(void)
+{
+#ifdef HAVE_GETUID
+#ifndef HAVE_ISSETUGID
+#define issetugid() (geteuid() != getuid() || getegid() != getgid())
+#endif
+	if (0 != getuid() && issetugid())
+	{ /*check as early as possible in main()*/
+		fprintf(stderr,
+				"Are you nuts ? Don't apply a SUID bit to this binary\n");
+		return 0;
+	}
+#endif
+
+#if defined(HAVE_MALLOPT) && defined(M_ARENA_MAX)
+#ifdef LIGHTTPD_STATIC
+	mallopt(M_ARENA_MAX, 2); /*(ignore error, if any)*/
+#else
+	{
+		int (*mallopt_fn)(int, int);
+		mallopt_fn = (int (*)(int, int))(intptr_t)dlsym(RTLD_DEFAULT, "mallopt");
+		if (mallopt_fn)
+			mallopt_fn(M_ARENA_MAX, 2); /*(ignore error, if any)*/
+	}
+#endif
+#endif
+
+#if defined(HAVE_MALLOC_TRIM)
+	malloc_top_pad = 524288;
+	{
+		const char *const top_pad_str = getenv("MALLOC_TOP_PAD_");
+		if (top_pad_str)
+		{
+			unsigned long top_pad = strtoul(top_pad_str, NULL, 10);
+			if (top_pad != ULONG_MAX)
+				malloc_top_pad = (size_t)top_pad;
+		}
+	}
+#ifdef LIGHTTPD_STATIC
+	malloc_trim_fn = malloc_trim;
+#else
+	malloc_trim_fn =
+		(int (*)(size_t))(intptr_t)dlsym(RTLD_DEFAULT, "malloc_trim");
+#endif
+#endif
+
+	/* for nice %b handling in strftime() */
+#ifdef _WIN32
+	setlocale(LC_ALL, "C.UTF-8");
+#ifdef __MINGW32__
+	_setmbcp(_MB_CP_LOCALE);
+#else
+	_setmbcp(_MB_CP_UTF8);
+#endif
+#else
+	setlocale(LC_TIME, "C");
+#endif
+	tzset();
+
+	return 1;
 }
 
 #ifndef server_status_running
-#define server_status_running(srv) do { } while (0)
+#define server_status_running(srv) \
+	do                             \
+	{                              \
+	} while (0)
 #endif
 
 #ifndef main
 #define server_main main
 #endif
 
-__attribute_cold__
-int server_main (int argc, char ** argv) {
-    if (!main_init_once()) return -1;
-
-    int rc;
-
-    do {
-        server * const srv = server_init();
-
-        if (graceful_restart) {
-            server_sockets_restore(srv);
-            optind = 1;
-        }
-
-        rc = server_main_setup(srv, argc, argv);
-        if (rc > 0) {
-            server_status_running(srv);
-
-            server_main_loop(srv);
-
-            if (graceful_shutdown || graceful_restart) {
-                server_graceful_state(srv);
-            }
-
-            if (NULL == srv->conns) rc = 0;
-            if (2 == graceful_shutdown) { /* value 2 indicates idle timeout */
-                log_error(srv->errh, __FILE__, __LINE__,
-                  "server stopped after idle timeout");
-            } else if (!oneshot_fd) {
-              #ifdef HAVE_SIGACTION
-                log_error(srv->errh, __FILE__, __LINE__,
-                  "server stopped by UID = %d PID = %d",
-                  (int)last_sigterm_info.si_uid,
-                  (int)last_sigterm_info.si_pid);
-              #else
-                log_error(srv->errh, __FILE__, __LINE__,
-                  "server stopped");
-              #endif
-            }
-        }
-
-        /* clean-up */
-        chunkqueue_internal_pipes(0);
-        remove_pid_file(srv);
-        config_log_error_close(srv);
-      #ifdef _WIN32
-        fdevent_win32_cleanup();
-      #endif
-        if (graceful_restart)
-            server_sockets_save(srv);
-        else
-            network_close(srv);
-        request_pool_free();
-        connections_free(srv);
-        plugins_free(srv);
-        server_free(srv);
-
-        if (rc < 0 || !graceful_restart) break;
-
-        /* wait for all children to exit before graceful restart */
-        while (fdevent_waitpid(-1, NULL, 0) > 0) ;
-    } while (graceful_restart);
-
-    return rc;
+__attribute_cold__ int server_main(int argc, char **argv)
+{
+	if (!main_init_once())
+		return -1;
+
+	int rc;
+
+	do
+	{
+		server *const srv = server_init();
+
+		if (graceful_restart)
+		{
+			server_sockets_restore(srv);
+			optind = 1;
+		}
+
+		rc = server_main_setup(srv, argc, argv);
+		if (rc > 0)
+		{
+			server_status_running(srv);
+
+			server_main_loop(srv);
+			if (graceful_shutdown || graceful_restart)
+			{
+				server_graceful_state(srv);
+			}
+
+			if (NULL == srv->conns)
+				rc = 0;
+			if (2 == graceful_shutdown)
+			{ /* value 2 indicates idle timeout */
+				log_error(srv->errh, __FILE__, __LINE__,
+						  "server stopped after idle timeout");
+			}
+			else if (!oneshot_fd)
+			{
+#ifdef HAVE_SIGACTION
+				log_error(srv->errh, __FILE__, __LINE__,
+						  "server stopped by UID = %d PID = %d",
+						  (int)last_sigterm_info.si_uid,
+						  (int)last_sigterm_info.si_pid);
+#else
+				log_error(srv->errh, __FILE__, __LINE__,
+						  "server stopped");
+#endif
+			}
+		}
+
+		/* clean-up */
+		chunkqueue_internal_pipes(0);
+		remove_pid_file(srv);
+		config_log_error_close(srv);
+#ifdef _WIN32
+		fdevent_win32_cleanup();
+#endif
+		if (graceful_restart)
+			server_sockets_save(srv);
+		else
+			network_close(srv);
+		request_pool_free();
+		connections_free(srv);
+		plugins_free(srv);
+		server_free(srv);
+
+		if (rc < 0 || !graceful_restart)
+			break;
+
+		/* wait for all children to exit before graceful restart */
+		while (fdevent_waitpid(-1, NULL, 0) > 0)
+			;
+	} while (graceful_restart);
+
+	return rc;
 }
