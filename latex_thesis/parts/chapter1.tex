\chapter{Introduction}

As the software systems are getting increasingly complex, ensuring their robustness and security has turned out to be a serious challenge. In this scenario, \textit{fuzzing} has emerged as a powerful technique in the identification of security vulnerabilities and defects, which may remain elusive for traditional testing techniques. Fuzzing involves the generation of random test inputs in order to see how the software reacts to unexpected or malformed input data, looking for problems, such as crashes, unexpected behaviour, or security vulnerabilities.
\\The evolution of fuzzing methodologies has significantly enhanced their effectiveness for a wide range of applications, such as:
%TODO: Add real references to the following examples
\begin{itemize}
    \item Google Chrome's \textbf{ClusterFuzz}, which has been instrumental in identifying thousands of security vulnerabilities in the Chrome browser (\textit{An Empirical Study of OSS-Fuzz Bugs \cite{ossfuzz}}).
    \item \textbf{SAGE}, which has been used to identify vulnerabilities in Windows (\textit{SAGE: Whitebox fuzzing for security testing \cite{sage}}).
    \item \textbf{Driller}, which has been used to identify vulnerabilities in the DARPA Cyber Grand Challenge (\textit{Driller: Augmenting Fuzzing Through Selective Symbolic Execution \cite{driller}}).
\end{itemize}
Traditional fuzzers typically focus on generating random inputs and observing the software responses. However, for applications that maintain internal states across several interactions, such as web servers or networked applications, this approach can be insufficient (\textit{Is Stateful Fuzzing Really Challenging? \cite{statefulfuzzing}}). These stateful applications call for more sophisticated fuzzing techniques that take into account the interaction between different states and transitions.
\\\textit{Stateful fuzzing} is an advanced approach for solving the problems of applications that rely on state management. Whereas in \textit{stateless fuzzing}, each input is considered a unique event, stateful fuzzing emulates the flow of activities along with the succeeding changes in the state of an application. It includes the generation of inputs which consider previous interactions and what these have done to the state of the application, hence providing a more realistic and deeper testing process.
\\An instance used in this thesis is \textbf{Lighttpd} (\textit{\href{https://github.com/lighttpd}{https://github.com/lighttpd}}), an \textit{open-source web server} recognized for its effectiveness and ability to scale, to manage a substantial number of concurrent connections. Assessing Lighttpd offers a chance to scrutinize stateful fuzzing methodologies.
\\This thesis focuses on the benchmarking of stateful fuzzers to ascertain their efficiency in \textit{coverage} in Lighttpd. The reviewed stateful fuzzers are: \textbf{Fallaway}, \textbf{AFLNet} and \textbf{ChatAFL}. Each of them has a its own approach toward stateful fuzzing.
\\By analyzing the performance of all these tools, this thesis will report the various strengths and weaknesses of each, which gives necessary suggestions for improving stateful fuzzing techniques and enhancing the security of modern software systems. In particular it will talk about the following aspects:
\begin{itemize}
    \item \textit{Fuzzing and stateful fuzzing}
    \item \textit{Lighttpd}
    \item \textit{AFLNet, ChatAFL and Fallaway}
    \item \textit{Setup and fuzzing}
    \item \textit{Results and analysis}
    \item \textit{Conclusions}
    \item \textit{Future works}
\end{itemize}