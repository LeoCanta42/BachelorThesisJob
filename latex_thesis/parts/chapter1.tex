\chapter{Introduction}

As the software systems are getting more complex, ensuring their robustness and security has turned out to be a serious challenge. In this scenario, \textit{fuzzing} has emerged as a powerful technique in the identification of security vulnerabilities and defects, which may remain elusive for traditional testing techniques, like \textit{static analysis, dynamic analysis and concolic analysis} ~\cite{vulndiscover}. Fuzzing involves the generation of random test inputs in order to see how the software reacts to unexpected or malformed input data, looking for problems, such as crashes, unexpected behaviour, or security vulnerabilities.
Taking some examples of these technologies, there is \textbf{SAGE} ~\cite{sage}, developed by Microsoft, which introduced fuzzing by using dynamic symbolic execution to explore different execution paths in software. This approach significantly contributed to identifying vulnerabilities in Windows by systematically generating inputs that maximize code coverage.
\\Another example is \textbf{ClusterFuzz} ~\cite{ossfuzz}, developed by Google, which is a large-scale fuzzing infrastructure that automates the testing of software like the Chrome browser. It has been instrumental in identifying thousands of security vulnerabilities by continuously running different fuzzers.
\\Furthermore, there is American Fuzzy Lop (\textbf{AFL} ~\cite{afl}), which introduced a new approach named \textit{coverage-guided fuzzing}. This approach uses feedback from program execution to guide the mutation of inputs, focusing on maximizing code coverage rather than generating inputs randomly.
\\Traditional fuzzers typically focus on generating inputs, in different ways, and observing the software responses. However, for applications that maintain internal states across several interactions, such as web servers or networked applications, this approach can be insufficient ~\cite{statefulfuzzingchallenges}. These stateful applications require more sophisticated fuzzing techniques that take into account the interaction between different states and transitions.
\\\textit{Stateful fuzzing} is an advanced approach for solving the problems of applications that rely on state models. Whereas in \textit{stateless fuzzing}, each input is considered a unique event, stateful fuzzing emulates the flow of activities along with the succeeding changes in the state of an application. It includes the generation of inputs which consider previous interactions and what these have done to the state of the application, hence providing a more realistic and deeper testing process.
\\In this thesis, we tested \textbf{Lighttpd} ~\cite{lighttpd}, an \textit{open-source web server} recognized for its effectiveness and ability to scale, to manage a substantial number of concurrent connections. Assessing Lighttpd offers a chance to scrutinize stateful fuzzing methodologies.
\\This thesis focuses on the benchmarking of stateful fuzzers to ascertain their efficiency in \textit{coverage} in Lighttpd. The reviewed stateful fuzzers are: \textbf{Fallaway}, \textbf{AFLNet} and \textbf{ChatAFL}. Each of them has a its own approach toward stateful fuzzing.
\\By analyzing the performance of all these tools, this thesis will report the various strengths and weaknesses of each, which gives necessary suggestions for improving stateful fuzzing techniques and enhancing the security of modern software systems.
\\The thesis is structured as follows: Chapter \ref{chap:background}, provides an overview of the background about fuzzing, fuzzers used in this thesis and the target. Chapter \ref{chap:Setup}, describes the setup of the environment and the configuration of the fuzzers. Chapter \ref{chap:Results}, presents the results obtained from the experiments.
\\Finally, Chapter \ref{chap:Conclusion}, summarizes the findings and provides suggestions for future work.